\chapter{Оптимизация доступа к удаленным массивам} \label{chapt4}
\section{Задача доставки требуемых элементов массива в память удаленных ВУ}
\textit{Постановка задачи}. Вычислительная система, состоящая из $n$ ВУ,
выполняет параллельную PGAS-программу в которой имеется цикл из $r$ итераций
рис.~\ref{list:r_iterations_loop}. Цикл выполняется главным процессом на ВУ 0
(локальный ВУ). В памяти локального ВУ хранится массив $а$ длинной $d$
элементов. На итерациях цикла при помощи языковых конструкций осуществляется
передача потока управления множеству $M$ ВУ (удаленный ВУ) для выполнения
выделенного фрагмента кода. Выделенный фрагмент кода, предназначенный для
выполнения на удаленном ВУ, содержит выражения в правой части которых
выполняется обращение к элементам массива $a$, расположенного в памяти
локального ВУ. Функция $f$ содержит такие выражения.

\begin{figure}[!h]
	\input{listings/r_iterations_loop.pc}
    \caption{Псевдокод циклического доступа удаленных ВУ к элементам массива
$a$}
    \label{list:r_iterations_loop}
\end{figure}

Для передачи потока управления удаленному ВУ runtime-библиотека копирует в его
память выеделенный фрагмент кода, который должен будет выполниться, и данные,
которые используются в этом коде, но не хранятся в памяти удаленного ВУ.

\textit{Требуется}. Разработать протокол копирования используемых элементов
массива $a$ в память множества ВУ $M$, таким образом, чтобы при выполнении цикла
из $r$ итераций достигался минимум $V$ суммарного объема передаваемых данных.

\subsection{Примитивный протокол копирования всего массива}
Современные языки, реализующие модель параллельного программирования PGAS,
такие как IBM X10 и Cray Chapel, для доставки требуемых элементов осуществляют
копирование всего массива $a$ в память удаленного ВУ.

Выполнение цикла из $r$ итераций с использованием данного алгоритма доставки
требуемых элементов (алгоритм -- $Generic$), приведет к тому, что массив $a$ на
каждой итерации целиком будет копироваться в память множества $M$ ВУ
(рис.~\ref{list:r_iterations_loop_generic}). Суммарный объем передаваемых данных
$V$ в этом случае будет равен:
\[ V = r \cdot |M| \cdot d. \]
\begin{figure}[!h]
	\input{listings/r_iterations_loop_generic.pc}
    \caption{Псевдокод копирования массива $a$ в память удаленных ВУ алгоритмом 
$Generic$}
    \label{list:r_iterations_loop_generic}
\end{figure}

\begin{figure}[!h]
	\input{listings/r_iterations_loop_scalar_replacement.pc}
    \caption{Псевдокод копирования массива $a$ в память удаленных ВУ алгоритмом
\textit{Scalar Replacement}}
    \label{list:r_iterations_loop_scalar_replacement}
\end{figure}

Для оценки времени выполнения цикла, в котором доставка требуемых элементов
осуществляется алгоритмом $Generic$ требуется рассмотреть 2 случая.
В первом случае, на каждой итерации цикла передача управления осуществляется
только одному ВУ. В этом случае время выполнения $T$ в моделях $LogP$, $LogGP$
и $Hockney$ будет равно
\[ T_{LogP} = (r - 1) \cdot g + L + 2 \cdot o. \]
\[ T_{LogGP} = o + ((d - 1) \cdot G + g) \cdot (r - 1) + (d - 1) \cdot G + L + o
= \]
\[ ((d - 1) \cdot G + g) \cdot (r - 1) + (d - 1) \cdot G + L + 2 \cdot o.\]
\[ T_{Hockney} = (\alpha + \beta \cdot d) \cdot r.\]

Во втором случае, на каждой итерации цикла управление передаётся всем $n$ ВУ
В этом случае время выполнения $T$ будет иметь вид:
\[ T_{LogP} = n \cdot g \cdot (r - 1) + (n - 1) \cdot g + o + L = \]
\[ g \cdot (n \cdot r + 1) + 2 \cdot o + L. \]
\[ T_{LogGP} = o + ((d - 1) \cdot G + g) \cdot (n - 1) \cdot (r - 1) +
(G \cdot (d -1) + g) \cdot (n - 2) + G \cdot (d - 1) + o = \]
\[ 2 \cdot o + (n - 1) \cdot (G \cdot d \cdot r + r \cdot (g - G)) - g. \]
\[ T_{Hockney} = r \cdot (\alpha + \beta \cdot d) \cdot n =\]
\[ \alpha \cdot r \cdot n + \beta \cdot r \cdot n \cdot d. \]
\subsection{Протокол доставки только используемых элементов}
Существуют альтернативные алгоритмы доставки данных на множество удаленных ВУ,
предпалагающие передачу только используемых элементов массива. В некоторых
случаях, на этапе компиляции представляется возможным определить множество $A$
индексов элементов массива, доступ к которым осуществляется удаленными ВУ.
В компиляторе языка IBM X10 реализованы различные трансформации кода для
оптимизации коммуникационных операций. В частности, реализован алгоритм
скалярной замены -- \textit{Scalar Replacement}, позволяющий копировать в память
удаленного ВУ только используемые элементы массива при передачи потока
управления. На рис.~\ref{list:r_iterations_loop_scalar_replacement} показан
псевдокод алгоритма выполнения цикла из $r$ итераций с использованием протокола
\textit{Scalar Replacement} для оптимизации передачи требуемых элементов массива
$a$. Функция $fscalar$ содержит выражения в правой части которых находятся
не элементы массива $a$, как в случае функции $f$, а их копии, представленные
временными скалярами $tmpScalars$. На каждой итерации цикла алгоритм
\textit{Scalar Replacement} выполняет следующие действия:
\begin{enumerate}
\item Копирует используемые элементы массива $a$ с индексами из множества $A$ в
массив временных скаляров $tmpScalars$
(рис.~\ref{list:r_iterations_loop_scalar_replacement}
строка~\ref{pc:r_iterations_loop_scalar_replacement:copy_to_tmpScalars});
\item Отправляет временные скаляры $tmpScalars$ множеству $M$ ВУ
(рис.~\ref{list:r_iterations_loop_scalar_replacement}
строка~\ref{pc:r_iterations_loop_scalar_replacement:bcast});
\item В выделенном для выполнения на удаленных ВУ фрагменте кода заменяет доступ
к элементам массива $a$ на доступ к соответствующим временными скалярами
(рис.~\ref{list:r_iterations_loop_scalar_replacement}
строка~\ref{pc:r_iterations_loop_scalar_replacement:replace_acces}).
\end{enumerate}

Суммарный объем передаваемых данных $V$ при выполнении цикла в случае
использования алгоритм \textit{Scalar Replacement} будет равен:
\[ V = r \cdot |M| \cdot |A|. \]

\begin{figure}[!h]
	\input{listings/r_iterations_loop_array_preload.pc}
    \caption{Псевдокод копирования массива $a$ в память удаленных ВУ алгоритмом
\textit{Array Preload}}
    \label{list:r_iterations_loop_array_preload}
\end{figure}

Время выполнения (случай 1 - передача управления только одному ВУ):
\[ T_{LogP} = (r - 1) \cdot g + L + o; \]
\[ T_{LogGP} =  o + ((c - 1) \cdot G + g) \cdot (r - 1) + (c - 1) \cdot G
+ L + o = \]
\[ r \cdot (G \cdot c - G + g) - g + o; \]
\[ T_{Hockney} = (\alpha + \beta \cdot c) \cdot r. \]

Время выполнения (случай 2 - передача управления всем ВУ):
\[ T_{LogP} = (n - 1) \cdot g \cdot (r - 1) + (n - 2) \cdot g + o + L + o = \]
\[ n \cdot r \cdot g - r \cdot g - g + L + 2 \cdot o; \]
\[ T_{LogGP} = o+((c-1) \cdot G + g) \cdot (n-1) \cdot (r-1) +
((c-1) \cdot G + g) \cdot (n - 2) + G \cdot (c-1) + o; \]
\[ r \cdot (G \cdot c - G + g) - g + o; \]
\[ T_{Hockney} = (\alpha + \beta \cdot c \cdot (n - 1)) \cdot r = \]
\[ \alpha \cdot r + \beta \cdot c \cdot (n - 1) \cdot r. \]

\subsection{Протокол опережающего копирования всего массива перед итерациями}
В работе предложен алгоритм \textit{Array Preload}, выполняющий опережающее
копирование массива $a$ в память множества $M$ удаленных ВУ. На
рис.~\ref{list:r_iterations_loop_array_preload} приведен псевдокод алгоритма
\textit{Array Preload} для организации выполнения цикла из $r$ итераций.
Функция $fpreloaded$  представляет собой функцию, эквивалентную $f$, в которой
выражения с элементами массива $a$ заменены на аналогичные с элементами
массива $tmpArray$. Массив $tmpArray$ копируется в память
удаленных ВУ один раз перед итерациями.
Предложенный алгоритм выполняет следующие действия:
\begin{enumerate}
\item Формирует пролог цикла для копирования массива $a$ в память удаленных ВУ
один раз перед итерациями (рис.~\ref{list:r_iterations_loop_array_preload}
строка~\ref{pc:r_iterations_loop_array_preload:prologue_begin}-
\ref{pc:r_iterations_loop_array_preload:prologue_end});
\item Заменяет, в выделенном фрагменте кода, доступ к элементам массива $a$ на
доступ к элементам заранее скопированного массива
$tmpArray$(рис.~\ref{list:r_iterations_loop_array_preload}
строка~\ref{pc:r_iterations_loop_array_preload:replace_acces}).
\end{enumerate}

Отличительной особенностью алгоритма \textit{Array Preload} является то, что
копирование массива $а$ в память удаленных ВУ будет происходить только один раз
перед выполнением цикла, а не на каждой итерации цикла, как в случае алгоритмов
\textit{generic} и \textit{Scalar Replacement}. Суммарный объем $V$ передаваемых
данных при выполнении цикла из $r$ итераций будет равен
\[ V= |M| \cdot d. \]

\section{Автоматическая трансформация цикла для использования протокола
  копирования только используемых элементов} \label{sect4_1}

Передача потока управления удаленному ВУ в цикле для выполнения на нем
выделенного фрагмента кода является частым действием в параллельных
PGAS-программах. Наличие такого шаблона в коде программы и отсутсвие
оптимизирующих техник трансформации таких циклов, позволяющих использовать
эффективные протоколы доставки требуемых элементов в память удаленных ВУ, могут
привести к возникновению существенных накладных расходов на выполнение
коммуникационных операций.

На данном этапе развития языков семейства PGAS в компиляторах используются
относительно простые эвристические алгоритмы (алгоритм \textit{Generic}).
Использование удаленным ВУ одного элемента массива, хранящегося в памяти
локального ВУ, приведет к избыточному копированию всех элементов массива
в его память (рис.~\ref{img:access_to_remote_array}).

\begin{figure}[!h] 
  \center
  \includegraphics [scale=1] {access_to_remote_array}
  \caption{Передача потока управления удаленному ВУ для выполнения фрагмента
    кода на языке IBM X10. \textit{Generic} протокол копирования
    элементов массива} 
  \label{img:access_to_remote_array}  
\end{figure}

\begin{figure}[!h] 
  \center
  \includegraphics [scale=1] {access_to_remote_array_opt_scalar_replacement}
  \caption{Передача потока управления удаленному ВУ для выполнения фрагмента
    кода на языке IBM X10. \textit{Scalar Replacement} протокол копирования
    элементов массива}
  \label{img:access_to_remote_array_opt_scalar_replacement}  
\end{figure}

Избыточное копирование всех элементов массива создаёт большие накладные расходы,
для сокращения которых используется алгоритм \textit{Scalar replacement}
[ссылка на литературу]), реализующий протокол передачи только используемых
элементов. Алгоритм предполагает использование временных скаляров вместо
элементов массивов в выделенных для выполнения на удаленных ВУ участках кода.
Временные скаляры являются копией элементов массива, к которым удаленный ВУ
осуществляет доступ. Таким образом, при обращении к созданным на удаленном ВУ
скалярам будет выполняться копирование только используемых элементов массива,
точнее, соответствующих им скаляров
~\ref{img:access_to_remote_array_opt_scalar_replacement}.

\todo{Добавить псевдокод алгоритма!}

\section{Автоматическая трансформация цикла для использования протокола
  опережающего копирования массива} \label{sect4_1}

В случае циклического 
обращения к элементам удаленного массива, runtime-система языка копирует весь 
массив на каждой итерации в память локального ВУ 
~\ref{img:access_to_remote_array_no_opt}, что является неприемлемым. 
Использование алгоритма Scalar Replacement в этой ситуации может привести к 
избыточному копированию: суммарное количество переданных элементов может 
оказаться больше размера всего массива. 

В диссертации предложен алгоритм автоматической трансформации цикла
(рис.~\ref{list:r_iterations_loop}), позволяющая использовать протокол
опережающего копирования массива \textit{Array Preload}.

\section{Алгоритм опережающего копирования удаленных массивов} \label{sect4_2}

Для предотвращения множественного копирования всего удаленного массива в память 
локального ВУ предложен алгоритм $ArrayPreload$ оптимизации циклического доступа 
к удаленным массивам, минимизирующий время информационных обменов. 
$ArrayPreload$ предотвращает многократное копирование массивов, размещенных в 
памяти других ВУ, выполняя опережающее копирование один раз перед итерациями 
цикла ~\ref{img:access_to_remote_array_no_opt}.

\begin{figure}[ht] 
  \center
  \includegraphics [scale=1] {access_to_remote_array_opt_arraypreload}
  \caption{Циклический доступ к элементу массива, расположенного в памяти 
удаленного ВУ. Оптимизированная версия $ArrayPreload$} 
  \label{img:access_to_remote_array_opt_arraypreload}  
\end{figure}

В листинге~\ref{list:at_exmpl_opt} показан пример оптимизации передачи массива 
$A$ для языка IBM X10. В случае не оптимизированной 
версии~\ref{list:at_exmpl_no_opt} на каждой итерации цикла массив $A$ передается 
узлу с номером $id$. В оптимизированной версии ~\ref{list:at_exmpl_opt} 
производится предварительное копирование массива $A$ на каждый узел один раз, 
сохранив его в распределённом массиве $localA$. Используемая языке IBM X10 
конструкция $at$ семантически соответствует конструкции $on$. 

\begin{ListingEnv}[!h]
    \begin{Verb}
for (i in 0..R) {
    val id: Long = i % Places.MAX_PLACES;
    at (Place.place(id)) {
        // Использование одного элемента A
        // приводит к копированию всего массива
        // на ВУ с номером placeId
        var a: Long = A(i % Size);
    }
}
    \end{Verb}
    \caption{Пример оптимизации передачи массива $A$ в параллельной программе на 
языке IBM X10. Не оптимизированная версия}
    \label{list:at_exmpl_no_opt}
\end{ListingEnv}

\begin{ListingEnv}[!h]
    \begin{Verb}
// Пролог цикла копирует A на каждый узел
// один раз, сохраняя его в распределённом
// массиве localA
val localA: DistArray[Array[Long]] = ...
for (i in 0..R) {
    val id: Long = i % Places.MAX_PLACES;
    at (Place.place(id)) {
        // Использование локальной копии localA
        // массива A
        var a: Long = localA(id)(i % Size);
    }
}
    \end{Verb}
    \caption{Пример оптимизации передачи массива $A$ в параллельной программе на 
языке IBM X10. Оптимизированная версия}
    \label{list:at_exmpl_opt}
\end{ListingEnv}

Алгоритм $ArrayPreload$ основан на статическом анализе PGAS-программы, 
представленной абстрактным синтаксическим деревом (АСД). Каждый узел в АСД имеет 
определенный тип в зависимости от выполняемой инструкции (например, операторы 
цикла, ветвления, конструкция передачи управления другому ВУ, объявление 
переменных и т.д.). На рис. \ref{img:ast_no_opt} приведен фрагмент АСД 
неоптимизированной программы из листинга \ref{list:at_exmpl_no_opt} на языке IBM 
X10 [13]. На вход $ArrayPreload$ поступает указатель на корень $Root$ АСД 
параллельной PGAS-программы. Результатом работы алгоритма является 
модифицированное АСД программы. 

\begin{figure}[ht] 
  \center
  \includegraphics [scale=0.7] {ast_no_opt}
  \caption{Фрагмент АСД параллельной PGAS программы на языке IBM X10, 
представленной на листинге \ref{list:at_exmpl_no_opt}} 
  \label{img:ast_no_opt}
\end{figure}

Все основные действия алгоритма производится во время рекурсивного обхода АСД в 
глубину. На первом этапе выполняется поиск циклов, содержащих обращения к 
элементам удаленных массивов. Рассмотрим подробнее этот этап. В 
листинге~\ref{list:array_preload_visit} приведен псевдокод функции $Visit$, 
выполняющая рекурсивный обход АСД в глубину. В процессе обхода отыскиваются узлы 
АСД с типом $Loop$, которые соответствуют оператору $for$ 
(листинг~\ref{list:array_preload_visit}, строка 5), и запускается функция 
анализа циклов (листинг~\ref{list:array_preload_visit}, строка 6).

Функция $ProcessLoop$ (листинг~\ref{list:array_preload_process_loop}) выполняет 
проход по всем инструкциям цикла (листинг~\ref{list:array_preload_process_loop}, 
строка 3) с целью поиска узла АСД типа $AtStmt$, который соответствует 
конструкции $at$ (синоним конструкции $on$) передачи управления другому ВУ 
(листинг~\ref{list:array_preload_process_loop}, строка 5). Для получения массива 
поддеревьев, соответствующих дочерним инструкциям, используется функция 
$GetStatements$. В случае обнаружения конструкции $at$ вызывается функция 
$ProcessAtStmt$ (листинг~\ref{list:array_preload_process_loop}, строка 6), 
реализующая поиск операции чтения элементов массива типа $Array$ 
(листинг~\ref{list:array_preload_process_at}). Для упрощения псевдокода в 
листинг~\ref{list:array_preload_process_at} рассматривается случай использования 
удаленных массивов только при объявлении переменных в выражениях инициализации 
($LocalDeclaration$). В общем случае последовательность действий анализа кода, 
выполняющегося на удаленном ВУ, будет зависеть от конкретной программной 
реализации модели PGAS. В процессе анализа инструкции $at$ перебираются все её 
инструкции до тех пор, пока не будет найден узел АСД с типом $LocalDeclaration$ 
(листинг~\ref{list:array_preload_process_at}, строка 3), указывающий на 
локальное объявление переменных. Затем необходимо проверить наличие операций 
чтения элементов массива в выражении инициализации. В описании алгоритма 
предполагается, что обращение к элементу массива выполняется при помощи вызова 
перегруженного оператора круглых скобок.  При помощи функции $GetInitialization$ 
получается узел АСД, соответствующий выражению инициализации объявляемой 
переменной (листинг~\ref{list:array_preload_process_at}, строка 4). Если 
полученный узел имеет тип $Call$ (указывает на вызов метода объекта, 
листинг~\ref{list:array_preload_process_at}, строка 5), а объект -- тип $Array$ 
(листинг~\ref{list:array_preload_process_at}, строка 6), то выражение содержит 
обращение к массиву. На этом завершается первый этап работы алгоритма.

\begin{ListingEnv}[!h]
	\small \VerbatimInput{listings/array_preload_visit.pc}
    \caption{Псевдокод $ArrayPreload$: рекурсивный обход АСД с поиском циклов и 
добавлением пролога цикла}    
    \label{list:array_preload_visit}
\end{ListingEnv}

\begin{ListingEnv}[!h]
	\small \VerbatimInput{listings/array_preload_process_loop.pc}
    \caption{Псевдокод $ArrayPreload$: функция анализа циклов}
    \label{list:array_preload_process_loop}
\end{ListingEnv} 
 
\begin{ListingEnv}[!h]
	\small \VerbatimInput{listings/array_preload_process_at.pc}
    \caption{Псевдокод $ArrayPreload$: функция анализа конструкции $at$}
    \label{list:array_preload_process_at}
\end{ListingEnv} 

На втором этапе (листинг~\ref{list:array_preload_process_at}, строка 7) 
выполняется проверка найденного массива. Для применения оптимизации необходимо 
убедиться в том, что массив не изменяется на протяжении всех итераций цикла, 
иначе применение оптимизации нарушит оригинальную семантику программы. Способ 
проверки неизменяемости массива зависит от реализации компилятора языка, 
например, данная проверка может быть реализована на основе заранее построенного 
контекста каждой инструкции цикла, или на основе контекста цикла целиком. 
Поэтому алгоритм проверки подробно не рассматривается, а используется функция 
$IsReadOnlyArray$, выполняющая её. Функция $IsReadOnlyArray$ возвращает истину, 
если массив не изменяется на протяжении всего цикла, ложь -- в противном случае. 
Функция $GetCallVarName$ возвращает имя объекта, чей метод вызывается.

На третьем этапе выполняется трансформация АСД параллельной программы. В случае 
успешной проверки найденного массива 
(листинг~\ref{list:array_preload_process_at}, строки 5-7) необходимо создать 
пролог цикла, копирующий удаленный массив в память ВУ один раз перед итерациями, 
а также произвести замену чтения удаленного массива на скопированную прологом 
цикла локальную копию. Опережающее копирование можно выполнить различными 
способами, в зависимости от реализации модели PGAS. В работе предложена 
реализация опережающего копирования при помощи использования распределенного 
массива. Достоинством данной реализации является то, что она не требует 
дополнительного расширения модели PGAS. Программист вручную может выполнять 
данные преобразования после тщательного анализа кода программы, но это 
трудоёмко.

Предлагаемая реализация заключается в создании распределенного массива длиной по 
количеству ВУ, элементы которого распределены по одному на каждый ВУ. Каждый 
элемент будет представлять копию удаленного массива. Таким образом, каждый ВУ 
будет хранить локальную копию используемого массива.

\noindent Для создания пролога цикла необходимо:
\begin{enumerate}
	\item Определить позицию оптимизируемого цикла в исходном коде 
(листинг~\ref{list:array_preload_process_at}, строка 8). Это необходимо для 
того, чтобы знать, куда необходимо вставить пролог цикла.
	\item Генерация имени локальной копии массива 
(листинг~\ref{list:array_preload_process_at}, строка 10).
	\item Формирование фрагмента АСД, который соответствует созданию 
распределенного массива для организации опережающего копирования согласно выше 
описанному способу (листинг~\ref{list:array_preload_process_at}, строка 11).
	\item Вставка сформированного фрагмента в заданную позицию АСД программы, а 
именно, перед рассматриваемым циклом 
(листинг~\ref{list:array_preload_process_at}, строка 16). Позиция цикла 
определялась в строке 8.
\end{enumerate}

\noindent После добавления пролога цикла необходимо выполнить замену чтения 
элементов удаленного массива на чтение элементов локальной копии. Для этого 
необходимо: 
\begin{enumerate}
	\item Получить имя локальной копии массива 
(листинг~\ref{list:array_preload_process_at}, строка 10).
	\item Получить список аргументов (листинг~\ref{list:array_preload_process_at}, 
строка 9). Так как обращение к элементу массива -- это вызов перегруженного 
оператора круглых скобок, то аргументом является индекс элемента массива. 
Обращение к локальной копии массива будет производиться по тем же самым 
индексам, что и обращение к удаленному массиву.
	\item Cоздать фрагмент АСД, выполняющий чтение используемых элементов 
локального массива (листинг~\ref{list:array_preload_process_at}, строка 14).
	\item Выполнить замену фрагментов АСД 
(листинг~\ref{list:array_preload_process_at}, строка 15).
\end{enumerate}

Рассмотрим описанные действия на фрагменте АСД из рис.~\ref{img:ast_no_opt}. В 
процессе рекурсивного обхода дерева будет обнаружен узел цикла $for\ (i\ in\ 
0..R)$, имеющий тип $Loop$. Поддерево с корнем, соответствующее циклу $for$, 
передаётся в функцию $ProcessLoop$ для поиска в теле цикла инструкции $at$ 
передачи управления другому ВУ. После обнаружения инструкции $at$ она передается 
в функцию $ProcessAtStmt$ для поиска в ней чтения элементов массива, 
расположенных в памяти удаленного ВУ. Таким массивом является $А$. Массив $А$ не 
изменяется на протяжении всего цикла, а значит можно произвести оптимизацию 
данного участка программы. Для опережающего копирования создаётся распределенный 
массив $localA$, элементами которого является массив $A$. После чего, в 
конструкции $at$ будет использоваться массив $localA$ вместо удаленного массива 
$A$. 

\begin{figure}[ht] 
  \center
  \includegraphics [scale=0.8] {ast_opt}
  \caption{Фрагмент АСД программы на языке IBM X10 после применения 
оптимизирующей трансформации (алгоритм $ArrayPreload$)} 
  \label{img:ast_opt}
\end{figure}

На рис.~\ref{img:ast_opt} приведен фрагмент АСД программы на языке IBM X10 после 
применения оптимизирующей трансформации. Жирным выделены узлы, подвергшиеся 
модификации. Был добавлен пролог цикла $val\ localA: DistArray[Array[Long]]$, а 
также, обращение к массиву $A$ заменено на обращение к массиву $localA$. 

\section{Исследование эффективности алгоритма оптимизация доступа к удаленным 
массивам} \label{sect4_3}

Исследование алгоритмов проводилось на вычислительных кластерах Jet (16 ВУ на 
базе двух четырёхъядерных процессоров Intel Xeon E5420, соединённых сетью 
Gigabit Ethernet) и Oak (6 ВУ на базе двух четырёхъядерных процессоров Intel 
Xeon E5420 соединённых сетью InfiniBand QDR) Центра параллельных вычислительных 
технологий ФГОБУ ВПО «Сибирский государственный университет телекоммуникаций и 
информатики» и Института физики полупроводников им. А.В. Ржанова СО РАН. 
Созданный алгоритм ($ArrayPreload$) программно реализован для языка IBM X10.

Для оценки эффективности алгоритмов $ArrayPreload$ и $Scalar\ replacement$ 
использовался синтетический тест -- циклический доступ к элементам массива, 
расположенным в памяти удаленных ВУ. Компилятор IBM X10 был собран с 
библиотеками MPICH2 3.0.4 (Jet) и MVAPICH2 2.0 (Oak). На 
рис.~\ref{results:arraypreload_scalarreplacement_jet} представлены графики 
зависимости коэффициента ускорения выполнения синтетического теста после 
применения алгоритмов оптимизации ($ArrayPreload$ 
рис.~\ref{results:arraypreload_jet}, $Scalar\ replacement$ 
рис.~\ref{results:scalar_replacement_jet}) от количества $N$ ВУ и числа $R$ 
обращений к массиву на кластере Jet с сетью связи Gigabit Ethernet. На данном 
тесте оба алгоритма демонстрируют ускорение от 5 до 82 раз. 

\begin{figure}[ht]
    {\centering
        \hfill
        \subcaptionbox[]{Алгоритм 
\textit{ArrayPreload}\label{results:arraypreload_jet}} 
{\includegraphics[width=0.5\linewidth]{results_arraypreload_jet}}%
        \hfill       
        \subcaptionbox{Алгоритм \textit{Scalar 
Replacement}\label{results:scalar_replacement_jet}} 
{\includegraphics[width=0.5\linewidth]{results_scalar_replacement_jet}}
        \hfill
    }
1 -- $D$ = 40000, $R$ = 40000; 2 -- $D$ = 40000, $R$ = 4000;\\
3 -- $D$ = 40000, $R$ = 400;   4 -- $D$ = 40000, $R$ = 40;
    \caption{Ускорение тестовой программы (кластер Jet)}
    \label{results:arraypreload_scalarreplacement_jet}
\end{figure}

\begin{figure}[ht] 
  \center
  \includegraphics [scale=1] {results_arraypreload_oak} \\
Алгоритм $ArrayPreload$ \\
1 -- $D$ = 40000, $R$ = 40000; 2 -- $D$ = 40000, $R$ = 4000;\\
3 -- $D$ = 40000, $R$ = 400;   4 -- $D$ = 40000, $R$ = 40;
  \caption{Ускорение тестовой программы (кластер Oak)} 
  \label{results:arraypreload_oak}
\end{figure}

На рис.~\ref{results:arraypreload_oak} показаны графики зависимости значения 
коэффициента ускорения выполнения X10-теста от количества $N$ ВУ после 
применения алгоритма $ArrayPreload$ на кластере Oak c сетью связи InfiniBand 
QDR. В ходе экспериментов варьировалось число $R$ обращений к удаленному 
массиву. В общем случае ускорение зависит от производительности коммуникационной 
сети, количества ВУ, размера массива, количества итераций в цикле (в теле 
которого организован циклический доступ).

\todo{Переработать эксперименты ниже}

Для обеспечения минимального суммарного объема передаваемых данных $V$ при
выполнении цикла, необходимо выбирать алгоритм доставки требуемых элементов 
массива в память удаленных ВУ. Выбор алгоритма осуществляется на этапе 
компиляции в зависимости от параметров цикла таких как количество элементов $d$ 
в массиве $a$, количество удаленных ВУ  $m = |M|$ которым передаётся поток 
управления для выполнения на них выделенного фрагмента кода, количество 
используемых элементов $c = |A|$ массива $a$ в выделенном фрагменте кода.

\begin{figure}[ht]
    \center
    \includegraphics [scale=1] {V_from_d} \\
    $r = 40000$ итераций, $m = 40$ ВУ, $c = 156$ элементов; \\
    1 -- алгоритм \textit{Generic}; 2 -- алгоритм \textit{Scalar Replacement}; 
\\
  	3 -- алгоритм \textit{Array Preload}.
    \caption{Зависимость суммарного объема передаваемых данных $V$ от количества 
элементов $d$ в массива $a$}
    \label{results:v_from_d}
\end{figure}

На рис.~\ref{results:v_from_d} показан график зависимости суммарного объема 
передаваемых данных $V$ от размера массива $d$ к элементам которого 
осуществляется доступ в выделенном фрагменте кода. В случае, когда размера 
массива $d$ равен 40000 элементов алгоритм \textit{Array Preload} позволяет в 15
раз сократить объем передаваемых данных по сравнению с алгоритмом \textit{Scalar
Replacement}.

\begin{figure}[ht]
    \center
    \includegraphics [scale=1] {V_from_m} \\
    $r = 40000$ итераций, $m = 40$ ВУ, $c = 156$ элементов; \\
    1 -- алгоритм \textit{Generic}; 2 -- алгоритм \textit{Scalar Replacement}; 
\\
  	3 -- алгоритм \textit{Array Preload}.
    \caption{Зависимость суммарного объема передаваемых данных $V$ от количества
ВУ $m$}
    \label{results:v_from_m}
\end{figure}

\begin{figure}[ht]
    \center
    \includegraphics [scale=1] {V_from_c} \\
    $r = 40000$ итераций, $m = 40$ ВУ, $c = 156$ элементов; \\
    1 -- алгоритм \textit{Generic}; 2 -- алгоритм \textit{Scalar Replacement}; 
\\
  	3 -- алгоритм \textit{Array Preload}.
    \caption{Зависимость суммарного объема передаваемых данных $V$ от количества
используемых элементов массива $c$}
    \label{results:v_from_d}
\end{figure}

\todo{конец текста для экспериментов}

%\newpage
%============================================================================================================================

% \section{Параграф - два} \label{sect3_2}

% Некоторый текст.

%\newpage
%============================================================================================================================

% \section{Параграф с подпараграфами} \label{sect3_3}

%\subsection{Подпараграф - один} \label{subsect3_3_1}

%Некоторый текст.

%\subsection{Подпараграф - два} \label{subsect3_3_2}

%Некоторый текст.

\clearpage

