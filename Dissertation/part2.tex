\chapter{Модель разделенного глобального адресного пространства} \label{chapt4}

Модель разделенного глобального адресного пространства (partitioned global address space -- PGAS) -- это модель параллельного программирования, реализующая общее адресное пространство над распределенной памятью ВС. В отличае от модели передачи сообщений в PGAS отсутствуют двусторонние коммуникационные операции (send/receive), а для обращения к памяти удаленной ЭМ используются односторонние коммуникационные операции (\textit{one-sided communication}). Таким образом, модель PGAS позволяет создавать программы для распределенных ВС используя семантику обращения к памяти ВС с общей памятью.

Создание параллельных программ в модели PGAS (\textit{PGAS-программ}) возможно с использованием $API$ или языковых конструкций, предоставляемых специальными языками программирования (\textit{PGAS-языка}). Библиотечный API реализует функции односторонних коммуникационных операций, которые используются при создании PGAS-программы. Библиотеки семейства $SHMEM$ являются наиболее известными, реализующие стандартизованное $API$ для создания PGAS-программ. Параллельная программа, разработанная при помощи API, предоставляемого библиотекой из семейства $SHMEM$, выполняется в модели \textit{SPMD -- single program, multiple data} (\textit{единая программа, множество данных}), т.е. одна и таже программа выполняется на множестве ЭМ распределенной ВС. Доступ к памяти удаленной ЭМ осуществляется при помощи операций \textit{shmem\_get} -- чтение и \textit{shmem\_put} -- запись.

Языки программирования семейства PGAS позволяют создавать параллельные программы не используя коммуникационные операции в явном виде. Вместе этого, PGAS-языки предоставляют языковые конструкции для работы с глобальным адресным пространством, реализованным над распределенной памятью ВС. Существующие PGAS-языки делятся на 2 поколения. Языки первого поколения создавались, чтобы объеденить преимущества модели $SPMD$ и ВС с общей памятью. Одним из таких активно развивающихся языков является $Unified\ Parallel\ C$ (UPC). В листинге~\ref{list:upc_example} показан пример реализации алгоритма умножения матрицы на вектор на языке UPC. Ключевое слово $shared$ используется при объявлении массивов $a$, $b$ и $c$ для того, чтобы сделать их распределенными. Тоесть, элементы этих массивов буду блочно храниться в распределенной памяти ВС. Обращение к элементам массива не требует от программиста использовать коммуникационные операции для доставки элементов массивов, хранимых в памяти удаленных ЭМ, эти обязанности ложатся на runtime-систему языка, которая может использовать односторонние коммуникационные операции.

\begin{ListingEnv}[ht]
	\small \VerbatimInput{listings/upc_example.pc}
    \caption{Пример умножения матрицы на вектор на языке UPC}
    \label{list:upc_example}
\end{ListingEnv}

PGAS-языки второго поколения разрабатывались как средства создания масштабируемых параллельных программ для ВС с распределенной памятью, удовлетворяющие следующим требованиям:
\begin{enumerate}
\item Распределенная память ВС представлена в виде единого глобального адресного пространства;
\item Все коммуникационные операции используются неявно runtime-системой языка;
\item Наличие единственного потока управления.
\end{enumerate}
К данному классу относятся следующие языки IBM X10, Cray Chapel и HPF. Отличительной особенностью PGAS-языков второго поколения от первого, является то, что они не реализуют модель SPMD. Выполнение PGAS-программы, разработанной на языке второго поколения, осуществляется в одном потоке управления на одной ЭМ -- \textit{главная ЭМ}. Оставшиеся ЭМ ВС принято называть \textit{подчиненными ЭМ}. Для выполнения параллельной обработки данных, в PGAS-языках второго поколения имеются конструкции порождения новых потоков управления как на текущей ЭМ, так и на удаленных ЭМ. Эти конструкции позволяют выделять участки кода для выполнения в новом потоке на текущей (в IBM X10 конструкция $async$) или на удаленной ЭМ (в IBM X10 конструкция $async$). Конструкция, в которой выделенный участок кода требуется выполнить на подчиненных ЭМ (удаленных ЭМ) называется -- \textit{конструкцией передачи управления подчиненным ЭМ}. Для идентификации ЭМ в PGAS-языках 2-го поколения введена специальная абстракция -- \textit{область} (в терминах языка IBM X10 -- $Place$).

\begin{ListingEnv}[ht]
	\small \VerbatimInput{listings/x10_example.pc}
    \caption{Фрагмент программы на языке IBM X10 умножения матрицы на вектор}
    \label{list:x10_example}
\end{ListingEnv}

Также как и в PGAS-языках первого поколения, в языках второго поколения предусмотрена возможность прозрачной работы с распределенными массивами. В листинге~\ref{list:x10_example} приведен фрагмент программы на языке IBM X10 умножения матрицы на вектор. В этом примере массив $a$ блоками хранится в распределенной памяти ВС. Массивы $b$ и $c$ созданы в памяти главной ЭМ. При помощи конструкии $at$ осуществляется передача потока управления подчиненной ЭМ в памяти которой хранится $i$-ая строка матрицы $a$. Подчиненная ЭМ выполняет произведение $i$-ой строки матрицы $a$ и вектора $b$. Результат произведения сохраняется в массиве $c$ при помощи глобальной ссылки $c_ref$.

При создании PGAS-программ программист использует только языковые конструкции и библиотечный API. Все коммуникационные операции генерируются PGAS-компилятором. компилятор языков программирования семейства PGAS является \textit{транспилером}, или интерпритатором, который код программы написаный на одном языке преобразует в аналогичный код, но на другом языке, как правило C/C++ или Java.

\section{Процесс выполнения PGAS-программы в модели передачи сообщений}

В этом разделе приводится интерпритация выполнения программ,
написаных на PGAS-языках второго поколения, в модели передачи сообщений.
Языковые PGAS-конструкции позволяют представить распределенную память ВС в виде
единого глобального адресного пространства. В таких языках отсутствует
возможность осуществлять явным образом коммуникационные операции. Все
информационные обмены между ЭМ выполняются неявно runtime-системой языка. 

Компилятор языков семейства PGAS транслирует языковые конструкци в
последовательность вызовов функций runtime-библиотеки, среди которых
присутствуют коммуникационные операции. Процесс выполнения PGAS-программы на ВС
с распределенной памятью определяется функционированием runtime-системы,
работа которой подобна организации вычислений в модели акторов \ref{}. Акторами
в данном случае выступают ЭМ, среди которых есть один главный (главная ЭМ).

\begin{figure}[!h]
	\input{listings/runtime_master.pc}
    \caption{Алгоритм работы runtime-системы главной ЭМ}
    \label{list:runtime_master}
\end{figure}

На рис~\ref{list:runtime_master} представлен алгоритм работы runtime-системы
на главной ЭМ абстрактного PGAS-языка. После запуска PGAS-программы главная ЭМ
выполняет следующие основные действия:
\begin{enumerate}
\item Рассылает всем подчиненным ЭМ сообщение, требующее выполнить
  инициализацию локальных данных ($InitMsg$);
\item Выполняет пользовательский код. Пользовательский код может содержать
  вызовы коммуникационных функций, необходимые для создания распределенных
  массивов, а также для организации передачи потока управления подчиненным ЭМ;
\item После завершения выполнения пользовательского кода рассылает всем
  подчиненным ЭМ сообщение, сигнализирующее о завершении выполнения
  PGAS-программы ($FinalizeMsg$).
\end{enumerate}  

\begin{figure}[!h]
	\input{listings/runtime_slave.pc}
    \caption{Алгоритм работы runtime-системы подчиненных ЭМ}
    \label{list:runtime_slave}
\end{figure}

Алгоритм работы runtime-системы подчиненных ЭМ показан на
рис~\ref{list:runtime_slave}. Каждая подчиненная ЭМ хранит очередь $q$ принятых
сообщений. Структура сообщения содержит поля $msg.code$ и $msg.data$. Поле
$msg.code$ в сериализованном виде хранит код, который был отправлен для
выполнения на текущей ЭМ. Данные, требуемые для выполнения этого кода,
в сериализованном виде хранятся в поле $msg.data$. После запуска PGAS-программы
на распределенной ВС подчиненные ЭМ ожидают сообщения инициализации $InitMsg$
от главной ЭМ. Получив данное сообщение ЭМ выполняют инициализацию локальных
данных, необходимых для работы runtime-системы. Вновь пришедшие сообщения
от главной ЭМ или от подчиненных помещаются в очередь $q$. Подчиненная ЭМ
извлекает из очереди сообщение и при помощи функции $ExecuteMsgCode$ выполняет
его код, содержащий команды тела конструкции передачи потока управления или
команды для создания части распределенного массива в локальной памяти текущей
ЭМ. Для выполнения кода сообщения фунция $ExecuteMsgCode$ сперва должна
десериализовать поля $code$ и $data$. Так продолжается до тех пор, пока не будет
извлечено сообщение $FinalizeMsg$, служащее сигналом завершения выполнения
PGAS-программы.

\section{Конструкция передачи потока управления подчиненным ЭМ}

В PGAS-языках второго поколения, таких как IBM X10 и Cray Chapel, присутствует
конструкция передачи потока управления от главной ЭМ к подчиненной. В языке
IBM X0 реализована конструкция $at$, в Cray Chapel -- конструкций $on$. Такие
конструкций позволяют выделять в программе участок кода, который требуется
выполнить на указанной ЭМ. Этот участок кода принято называть
\textit{Телом конструкции}.

\begin{ListingEnv}[ht]
	\small \VerbatimInput{listings/x10_at_construction.pc}
    \caption{Пример использования конструкции $at$ на языке $IBM\ X10$}
    \label{list:x10_at_construction}
\end{ListingEnv}

Листинг~\ref{list:x10_at_construction} демонстрирует пример использования
конструкции $at$ передачи потока управления подчиненным ЭМ на языке $IBM\ X10$.
В этом примере осуществляется вызов функции $ComputeSum$ суммирования элементов
массива $a$ на подчиненной ЭМ (удаленной ЭМ). Параметр $world.next(here)$
конструкции $at$ указывает ЭМ которой будет передано управление. Тело
конструкции содержит код, выполняемый указанной ЭМ. В указанном выше примере
тело конструкции содержит вызов функции $ComputeSum$, которой в качестве
аргумента передаётся массив $a$.

Для выполнения тела конструкции передачи потока управления подчиненной ЭМ
необходимо скопировать в память ЭМ код конструкции (функцию $ComputeSum$)
и используемые данные (массив $a$). Для этого, компилятор PGAS-языка преобразует
конструкцию $at$ следующим образом:
\begin{enumerate}
\item Выделяет тело конструкции в отдельную фунцию;
\item Создаёт сообщение, передаваемое подчиненной ЭМ, которое в сериализованном
  виде содержит функцию -- тело конструкции $at$ и используемые данные;
\item Вставляет вызовы коммуникационных функций для отправки созданного
  сообщения подчиненной ЭМ.
\end{enumerate}

\begin{ListingEnv}[ht]
	\small \VerbatimInput{listings/x10_intermediate_at_construction.pc}
    \caption{Пример трансформации конструкции $at$ PGAS-компилятором}
    \label{list:x10_intermediate_at_construction}
\end{ListingEnv}

В листине~\ref{list:x10_intermediate_at_construction} показан пример
$X10$-подобного промежуточного представления, полученного после преобразования
конструкции $at$ PGAS-компилятором программы, приведенной в
листинге~\ref{list:x10_at_construction}. В результате формируется функция
$BodyAt$, содержащая код тела конструкции $at$, вставлены вызовы фунций
сериализации $Serialize$ и функция $Send$ для отправки созданного сообщения
$msg$ подчиненной ЭМ с номером $id$.

\begin{figure}[!h] 
  \center
  \includegraphics [scale=0.95] {transfer_control}
  \caption{Выполнение конструкции передачи потока управления подчиненной ЭМ}
  \label{img:transfer_control}  
\end{figure}

На рис~\ref{img:transfer_control} изображена интерпритация выполнения
конструкции передачи потока управления подчиненным ЭМ
(листинг~\ref{list:x10_intermediate_at_construction}) в модели передачи
сообщений. Во время выполнения PGAS-программы runtime-система языка при помощи
функции $Serialize$ сериализует код тела конструкции $at$, который на этапе
компиляции преобразован в фунцию $BodyAt$. Массив $a$, хранимый в памяти главной
ЭМ, также сериализуется в последовательность байт для отправки подчиненной ЭМ с
номером $id$. Результаты сериализации сохраняются в сообщении $msg$, в полях
$code$ и $data$. После завершения формирования сообщения осуществляется его
отправка ЭМ с номером $id$ при помощи функции $Send$.

Принятые сообщения подчиненной ЭМ с номером $id$ сохраняются в очереди $q$.
Runtime-система подчиненной ЭМ извлекает из очереди сообщение $msg$ и при помощи
функции $ExecuteMsgCode$ выполняет код сообщения, предварительно выполнив его
десериализацию. В данном случае, ЭМ с номером $id$ выполнит отправленную ей
фунцию $BodyAt$ на массивом $a$.

\section{Конструкция циклической передачи потока управления подчиненным ЭМ}

%% е присутствует конструкция передачи потока управления от
%% главной ЭМ множеству $M$ ЭМ для выполнения ими выделенного фрагмента кода.
%% Правая часть выражений в выделенном фрагменте кода содержит обращения
%% к элементам массива $a$, расположенного в памяти главной ЭМ. Конструкция
%% передачи потока управления подчиненной ЭМ подразумевает доставку в её память
%% выделенного фрагмента кода и используемых данных, которые хранятся в памяти
%% главной ЭМ. В листинге~\ref{list:r_iterations_loop} показан пример подобного
%% шаблона цикла на языке \textit{IBM X10}. Вызов функции $f(a)$ содержит выражения
%% в правой части которых находятся элементы передаваемого в качестве аргумента
%% массива $a$. Примером такой функции может быть реализация алгоритма вычисления
%% суммы всех элементов массива или его части. Для передачи потока управления
%% подчиненной ЭМ с номером $j$, runtime-библиотека языка копирует в её память
%% функцию $f$, которая будет выполниться, и массив $a$, который хранится в памяти
%% главной ЭМ.



%% Перед началом цикла runtime-система языка выбирает алгоритм, определяющий способ
%% доставки массива $a$ в память подчиненных ЭМ, а также  порядок выполнения
%% итераций. Существует два основных алгоритма выполнения цикла. Первый алгоритм
%% \textit{Generic} подразумевает поочередное копирование всего массива $a$
%% в память ЭМ $j$ на каждой итерации цикла. Второй алгоритм осуществляет
%% копирование только используемых элементов массива $a$ в память ЭM $j$.
%% Эти алгоритмы повсеместно используются современными языками, реализующими модель
%% параллельного программирования PGAS, такими как IBM X10 и Cray Chapel (UPC).

\todo {Описание циклической конструкции передачи потока управления подчиненным
  ЭМ}

\begin{ListingEnv}[ht]
	\small \VerbatimInput{listings/r_iterations_loop.pc}
    \caption{Доступ подчиненных ЭМ к массиву $a$ на языке $IBM\ X10$}
    \label{list:r_iterations_loop}
\end{ListingEnv}


\section{Задача выполнения конструкций циклической передачи потока управления
  подчиненным ЭМ}

\textit{Постановка задачи}. В параллельная PGAS-программе дан цикл из $r$
итераций (листинг~\ref{list:r_iterations_loop}). Цикл удовлетворяет следующим
условиям:
\begin{enumerate}
\item В цикле присутствует конструкция передачи потока управления ЭМ из
  множества $M$;
\item Тело конструкции передачи потока управления подчиненной ЭМ может быть
  представленно функциями $f_{1}(a_{1}), f_{2}(a_{2}),...$;
\item Массивы $a_{1},...$ в памяти главной ЭМ не требуют согласования состояния
  с массивами в памяти подчиненных ЭМ.
\end{enumerate}

Во время компляции

\textit{Требуется}. Разработать алгоритм выполнения циклических конструкций
передачи потока управления ЭМ из множества $M$.

Основные действия алгоритма, осуществляются на этапе компиляции программы.
На вход алгоритма поступает промежуточное представление кода конструкции
циклической передачи потока управления подчиненным ЭМ, представленное
абстрактным синтаксическим деревом (АСД). Во время компиляции алгоритм
трансформирует цикл, преобразует конструкцию передачи потока управления в
последовательность вызовов функций runtime-библиотеки для копирования функций
$f_{1},...$ и доставки массивов $a_{1},...$ в память подчиненных ЭМ. Таким
образом результатом работы алгоритма является модифицированная программа.

На этапе выполнения runtime-библиотека копирует используемые массивы в память
подчиненных ЭМ при помощи дифференцированных или коллективных информационных
обменов.

\section{Алгоритмы выполнения конструкций циклической передачи потока управления
  подчиненным ЭМ}

PGAS-языки второго поколени для выполнения конструкций циклической
передачи потока управления подчиненным ЭМ чаще всего используют алгоритм,
выполняющий копирования массивов $a_{1},...$ целиком в память подчиненных ЭМ
на каждой итерации (алгоритм \textit{Default}). Этот алгоритм не требует
сложного анализа промежуточного представления тела конструкций на этапе
компиляции программы, так как используемые массивы передатся подчиненным ЭМ из
множества $M$ на каждой итерации $i=\{0..r-1\}$. Достоинством данного алгоритма
является универсальность его использования, т.е. возможность использования
для конструкций всех возможных видов. Однако, существенный недостаток этого
алгоритма заключается в том, что на каждой итерации цикла осуществляется
избыточное копирование всех элементов используемых массивов $a_{1},...$.

Для сокращения накладных расходов на избыточное копирование массивов в память
подчиненных ЭМ предложен алгоритм \textit{Scalar Replacement}. Алгоритм
осуществляет копирование массивов $a_{1},...$ в память подчиненных ЭМ
не целиком, как в случае использования алгоритма \textit{Default}, а только
их используемых эллементов. Данный алгоритм требует дополнительных действий на
этапе статического анализа промежуточного представления PGAS-программы, так как
необходимо определить индексы используемых эллементов. Недостатком данного
алгоритма является ограниченность его приминения, а именно, алгоритм не применим
в случае, если на этапе статического анализа промежуточного представления
программы не представляется возможным определить значения индексов используемых
эллементов массивов $a_{1},...$.

Чтобы избежать недостатки \textit{Scalar Replacement} предложен алгоритм
\textit{Array Preload}, который также позволяет сократить накладные расходы
на избыточное копирование массивов $a_{1},...$ в память подчиненных ЭМ. Алгоритм
\textit{Array Preload} выполняет опережающее копирование массивов $a_{1},...$
в память подчиненных ЭМ один раз перед выполнением цикла из $r$ итераций.
Так как массивы копируются целиком, а не только используемые элементы,
алгоритм может быть применим в случае использования конструкций циклической
передачи потока управления подчиненным ЭМ в теле которых осуществляется доступ к
элементам массивов $a_{1},...,$ индексы которых невозможно определить на этапе
статического анализа кода PGAS-программы. Недостатком алгоритма
\textit{Array Preload} является необходимость на этапе компиляции производить
существенную трансформацию конструкции циклической передачи управления
подчиненной ЭМ, так как необходимо добавить пролог цикла и изменить обращения
к массивам $a_{1},...,$.

\todo {
  Добавить таблицу сравнения алгоритмов.
  }

\subsection{Алгоритм \textit{Default}}

Алгоритм \textit{Default} является наиболее часто используемым для организации
выполнения циклических конструкций передачи потока управления подчиненным ЭМ.
На вход алгоритма поступает АСД $T$
Результатом работы данного алгоритма будет являться программа, в которой
копирование массивов $a_{1},...$ в память ЭМ из множества $M$ осуществляется на
каждой итерации $i=\{0..r-1\}$.

Выполнение цикла из $r$ итераций с использованием данного алгоритма доставки
требуемых элементов (алгоритм -- $Generic$), приведет к тому, что массив $a$ на
каждой итерации целиком будет копироваться в память множества $M$ ВУ
(рис.~\ref{list:r_iterations_loop_generic}). Суммарный объем передаваемых данных
$V$ в этом случае будет равен:
\[ V = r \cdot |M| \cdot d. \]
\begin{figure}[!h]
	\input{listings/r_iterations_loop_generic.pc}
    \caption{Псевдокод копирования массива $a$ в память удаленных ВУ алгоритмом 
$Generic$}
    \label{list:r_iterations_loop_generic}
\end{figure}

\begin{figure}[!h]
	\input{listings/r_iterations_loop_scalar_replacement.pc}
    \caption{Псевдокод копирования массива $a$ в память удаленных ВУ алгоритмом
\textit{Scalar Replacement}}
    \label{list:r_iterations_loop_scalar_replacement}
\end{figure}

Для оценки времени выполнения цикла, в котором доставка требуемых элементов
осуществляется алгоритмом $Generic$ требуется рассмотреть 2 случая.
В первом случае, на каждой итерации цикла передача управления осуществляется
только одному ВУ. В этом случае время выполнения $T$ в моделях $LogP$, $LogGP$
и $Hockney$ будет равно
\[ T_{LogP} = (r - 1) \cdot g + L + 2 \cdot o. \]
\[ T_{LogGP} = o + ((d - 1) \cdot G + g) \cdot (r - 1) + (d - 1) \cdot G + L + o
= \]
\[ ((d - 1) \cdot G + g) \cdot (r - 1) + (d - 1) \cdot G + L + 2 \cdot o.\]
\[ T_{Hockney} = (\alpha + \beta \cdot d) \cdot r.\]

Во втором случае, на каждой итерации цикла управление передаётся всем $n$ ВУ
В этом случае время выполнения $T$ будет иметь вид:
\[ T_{LogP} = n \cdot g \cdot (r - 1) + (n - 1) \cdot g + o + L = \]
\[ g \cdot (n \cdot r + 1) + 2 \cdot o + L. \]
\[ T_{LogGP} = o + ((d - 1) \cdot G + g) \cdot (n - 1) \cdot (r - 1) +
(G \cdot (d -1) + g) \cdot (n - 2) + G \cdot (d - 1) + o = \]
\[ 2 \cdot o + (n - 1) \cdot (G \cdot d \cdot r + r \cdot (g - G)) - g. \]
\[ T_{Hockney} = r \cdot (\alpha + \beta \cdot d) \cdot n =\]
\[ \alpha \cdot r \cdot n + \beta \cdot r \cdot n \cdot d. \]

\subsection{Алгоритм \textit{Scalar Replacement}}

\todo {In progress}

\subsection{Алгоритм \textit{Array Preload}}

\todo {In progress}


 \todo{ Алгоритм выполнения циклической конструкции передачи потока управления
   множеству ЭМ, основанный на механизме опережающего копирования }


\textit{Требуется}. Разработать метод выбора алгоритма выполнения циклических
конструкций передачи потока управления множеству $M$ ЭМ, обеспечивающего минимум
времени $T$ выполнения цикла.

\todo {
Вычислительная система, состоящая из $n$ ЭМ,
выполняет параллельную PGAS-программу в которой имеется цикл из $r$ итераций.
Цикл выполняется процессом на ЭМ 0 (главная ЭМ). В памяти локальной ЭМ
хранится массив $а$ длинной $d$ элементов. На итерациях цикла при помощи
языковых конструкций осуществляется передача потока управления множеству $M$ ЭМ
(подчиненные ЭМ) для выполнения выделенного фрагмента кода.
Выделенный фрагмент кода, предназначенный для выполнения на удаленных ЭМ,
содержит выражения в правой части которых выполняется обращение к элементам
массива $a$, расположенного в памяти главной ЭМ.
}

Существуют альтернативные алгоритмы доставки данных на множество удаленных ВУ,
предпалагающие передачу только используемых элементов массива. В некоторых
случаях, на этапе компиляции представляется возможным определить множество $A$
индексов элементов массива, доступ к которым осуществляется удаленными ВУ.
В компиляторе языка IBM X10 реализованы различные трансформации кода для
оптимизации коммуникационных операций. В частности, реализован алгоритм
скалярной замены -- \textit{Scalar Replacement}, 



\subsection{Примитивный протокол копирования всего массива}


\subsection{Протокол доставки только используемых элементов}
Существуют альтернативные алгоритмы доставки данных на множество удаленных ВУ,
предпалагающие передачу только используемых элементов массива. В некоторых
случаях, на этапе компиляции представляется возможным определить множество $A$
индексов элементов массива, доступ к которым осуществляется удаленными ВУ.
В компиляторе языка IBM X10 реализованы различные трансформации кода для
оптимизации коммуникационных операций. В частности, реализован алгоритм
скалярной замены -- \textit{Scalar Replacement}, позволяющий копировать в память
удаленного ВУ только используемые элементы массива при передачи потока
управления. На рис.~\ref{list:r_iterations_loop_scalar_replacement} показан
псевдокод алгоритма выполнения цикла из $r$ итераций с использованием протокола
\textit{Scalar Replacement} для оптимизации передачи требуемых элементов массива
$a$. Функция $fscalar$ содержит выражения в правой части которых находятся
не элементы массива $a$, как в случае функции $f$, а их копии, представленные
временными скалярами $tmpScalars$. На каждой итерации цикла алгоритм
\textit{Scalar Replacement} выполняет следующие действия:
\begin{enumerate}
\item Копирует используемые элементы массива $a$ с индексами из множества $A$ в
массив временных скаляров $tmpScalars$
(рис.~\ref{list:r_iterations_loop_scalar_replacement}
строка~\ref{pc:r_iterations_loop_scalar_replacement:copy_to_tmpScalars});
\item Отправляет временные скаляры $tmpScalars$ множеству $M$ ВУ
(рис.~\ref{list:r_iterations_loop_scalar_replacement}
строка~\ref{pc:r_iterations_loop_scalar_replacement:bcast});
\item В выделенном для выполнения на удаленных ВУ фрагменте кода заменяет доступ
к элементам массива $a$ на доступ к соответствующим временными скалярами
(рис.~\ref{list:r_iterations_loop_scalar_replacement}
строка~\ref{pc:r_iterations_loop_scalar_replacement:replace_acces}).
\end{enumerate}

Суммарный объем передаваемых данных $V$ при выполнении цикла в случае
использования алгоритм \textit{Scalar Replacement} будет равен:
\[ V = r \cdot |M| \cdot |A|. \]

\begin{figure}[!h]
	\input{listings/r_iterations_loop_array_preload.pc}
    \caption{Псевдокод копирования массива $a$ в память удаленных ВУ алгоритмом
\textit{Array Preload}}
    \label{list:r_iterations_loop_array_preload}
\end{figure}

Время выполнения (случай 1 - передача управления только одному ВУ):
\[ T_{LogP} = (r - 1) \cdot g + L + o; \]
\[ T_{LogGP} =  o + ((c - 1) \cdot G + g) \cdot (r - 1) + (c - 1) \cdot G
+ L + o = \]
\[ r \cdot (G \cdot c - G + g) - g + o; \]
\[ T_{Hockney} = (\alpha + \beta \cdot c) \cdot r. \]

Время выполнения (случай 2 - передача управления всем ВУ):
\[ T_{LogP} = (n - 1) \cdot g \cdot (r - 1) + (n - 2) \cdot g + o + L + o = \]
\[ n \cdot r \cdot g - r \cdot g - g + L + 2 \cdot o; \]
\[ T_{LogGP} = o+((c-1) \cdot G + g) \cdot (n-1) \cdot (r-1) +
((c-1) \cdot G + g) \cdot (n - 2) + G \cdot (c-1) + o; \]
\[ r \cdot (G \cdot c - G + g) - g + o; \]
\[ T_{Hockney} = (\alpha + \beta \cdot c \cdot (n - 1)) \cdot r = \]
\[ \alpha \cdot r + \beta \cdot c \cdot (n - 1) \cdot r. \]

\subsection{Протокол опережающего копирования всего массива перед итерациями}
В работе предложен алгоритм \textit{Array Preload}, выполняющий опережающее
копирование массива $a$ в память множества $M$ удаленных ВУ. На
рис.~\ref{list:r_iterations_loop_array_preload} приведен псевдокод алгоритма
\textit{Array Preload} для организации выполнения цикла из $r$ итераций.
Функция $fpreloaded$  представляет собой функцию, эквивалентную $f$, в которой
выражения с элементами массива $a$ заменены на аналогичные с элементами
массива $tmpArray$. Массив $tmpArray$ копируется в память
удаленных ВУ один раз перед итерациями.
Предложенный алгоритм выполняет следующие действия:
\begin{enumerate}
\item Формирует пролог цикла для копирования массива $a$ в память удаленных ВУ
один раз перед итерациями (рис.~\ref{list:r_iterations_loop_array_preload}
строка~\ref{pc:r_iterations_loop_array_preload:prologue_begin}-
\ref{pc:r_iterations_loop_array_preload:prologue_end});
\item Заменяет, в выделенном фрагменте кода, доступ к элементам массива $a$ на
доступ к элементам заранее скопированного массива
$tmpArray$(рис.~\ref{list:r_iterations_loop_array_preload}
строка~\ref{pc:r_iterations_loop_array_preload:replace_acces}).
\end{enumerate}

Отличительной особенностью алгоритма \textit{Array Preload} является то, что
копирование массива $а$ в память удаленных ВУ будет происходить только один раз
перед выполнением цикла, а не на каждой итерации цикла, как в случае алгоритмов
\textit{generic} и \textit{Scalar Replacement}. Суммарный объем $V$ передаваемых
данных при выполнении цикла из $r$ итераций будет равен
\[ V= |M| \cdot d. \]

\section{Автоматическая трансформация цикла для использования протокола
  копирования только используемых элементов} \label{sect4_1}

Передача потока управления удаленному ВУ в цикле для выполнения на нем
выделенного фрагмента кода является частым действием в параллельных
PGAS-программах. Наличие такого шаблона в коде программы и отсутсвие
оптимизирующих техник трансформации таких циклов, позволяющих использовать
эффективные протоколы доставки требуемых элементов в память удаленных ВУ, могут
привести к возникновению существенных накладных расходов на выполнение
коммуникационных операций.

На данном этапе развития языков семейства PGAS в компиляторах используются
относительно простые эвристические алгоритмы (алгоритм \textit{Generic}).
Использование удаленным ВУ одного элемента массива, хранящегося в памяти
локального ВУ, приведет к избыточному копированию всех элементов массива
в его память (рис.~\ref{img:access_to_remote_array}).

\begin{figure}[!h] 
  \center
  \includegraphics [scale=1] {access_to_remote_array}
  \caption{Передача потока управления удаленному ВУ для выполнения фрагмента
    кода на языке IBM X10. \textit{Generic} протокол копирования
    элементов массива} 
  \label{img:access_to_remote_array}  
\end{figure}

\begin{figure}[!h] 
  \center
  \includegraphics [scale=1] {access_to_remote_array_opt_scalar_replacement}
  \caption{Передача потока управления удаленному ВУ для выполнения фрагмента
    кода на языке IBM X10. \textit{Scalar Replacement} протокол копирования
    элементов массива}
  \label{img:access_to_remote_array_opt_scalar_replacement}  
\end{figure}

Избыточное копирование всех элементов массива создаёт большие накладные расходы,
для сокращения которых используется алгоритм \textit{Scalar replacement}
[ссылка на литературу]), реализующий протокол передачи только используемых
элементов. Алгоритм предполагает использование временных скаляров вместо
элементов массивов в выделенных для выполнения на удаленных ВУ участках кода.
Временные скаляры являются копией элементов массива, к которым удаленный ВУ
осуществляет доступ. Таким образом, при обращении к созданным на удаленном ВУ
скалярам будет выполняться копирование только используемых элементов массива,
точнее, соответствующих им скаляров
~\ref{img:access_to_remote_array_opt_scalar_replacement}.

\todo{Добавить псевдокод алгоритма!}

\section{Автоматическая трансформация цикла для использования протокола
  опережающего копирования массива} \label{sect4_1}

В случае циклического 
обращения к элементам удаленного массива, runtime-система языка копирует весь 
массив на каждой итерации в память локального ВУ 
~\ref{img:access_to_remote_array_no_opt}, что является неприемлемым. 
Использование алгоритма Scalar Replacement в этой ситуации может привести к 
избыточному копированию: суммарное количество переданных элементов может 
оказаться больше размера всего массива. 

В диссертации предложен алгоритм автоматической трансформации цикла
(рис.~\ref{list:r_iterations_loop}), позволяющая использовать протокол
опережающего копирования массива \textit{Array Preload}.

\section{Алгоритм опережающего копирования удаленных массивов} \label{sect4_2}

Для предотвращения множественного копирования всего удаленного массива в память 
локального ВУ предложен алгоритм $ArrayPreload$ оптимизации циклического доступа 
к удаленным массивам, минимизирующий время информационных обменов. 
$ArrayPreload$ предотвращает многократное копирование массивов, размещенных в 
памяти других ВУ, выполняя опережающее копирование один раз перед итерациями 
цикла ~\ref{img:access_to_remote_array_no_opt}.

\begin{figure}[ht] 
  \center
  \includegraphics [scale=1] {access_to_remote_array_opt_arraypreload}
  \caption{Циклический доступ к элементу массива, расположенного в памяти 
удаленного ВУ. Оптимизированная версия $ArrayPreload$} 
  \label{img:access_to_remote_array_opt_arraypreload}  
\end{figure}

В листинге~\ref{list:at_exmpl_opt} показан пример оптимизации передачи массива 
$A$ для языка IBM X10. В случае не оптимизированной 
версии~\ref{list:at_exmpl_no_opt} на каждой итерации цикла массив $A$ передается 
узлу с номером $id$. В оптимизированной версии ~\ref{list:at_exmpl_opt} 
производится предварительное копирование массива $A$ на каждый узел один раз, 
сохранив его в распределённом массиве $localA$. Используемая языке IBM X10 
конструкция $at$ семантически соответствует конструкции $on$. 

\begin{ListingEnv}[!h]
    \begin{Verb}
for (i in 0..R) {
    val id: Long = i % Places.MAX_PLACES;
    at (Place.place(id)) {
        // Использование одного элемента A
        // приводит к копированию всего массива
        // на ВУ с номером placeId
        var a: Long = A(i % Size);
    }
}
    \end{Verb}
    \caption{Пример оптимизации передачи массива $A$ в параллельной программе на 
языке IBM X10. Не оптимизированная версия}
    \label{list:at_exmpl_no_opt}
\end{ListingEnv}

\begin{ListingEnv}[!h]
    \begin{Verb}
// Пролог цикла копирует A на каждый узел
// один раз, сохраняя его в распределённом
// массиве localA
val localA: DistArray[Array[Long]] = ...
for (i in 0..R) {
    val id: Long = i % Places.MAX_PLACES;
    at (Place.place(id)) {
        // Использование локальной копии localA
        // массива A
        var a: Long = localA(id)(i % Size);
    }
}
    \end{Verb}
    \caption{Пример оптимизации передачи массива $A$ в параллельной программе на 
языке IBM X10. Оптимизированная версия}
    \label{list:at_exmpl_opt}
\end{ListingEnv}

Алгоритм $ArrayPreload$ основан на статическом анализе PGAS-программы, 
представленной абстрактным синтаксическим деревом (АСД). Каждый узел в АСД имеет 
определенный тип в зависимости от выполняемой инструкции (например, операторы 
цикла, ветвления, конструкция передачи управления другому ВУ, объявление 
переменных и т.д.). На рис. \ref{img:ast_no_opt} приведен фрагмент АСД 
неоптимизированной программы из листинга \ref{list:at_exmpl_no_opt} на языке IBM 
X10 [13]. На вход $ArrayPreload$ поступает указатель на корень $Root$ АСД 
параллельной PGAS-программы. Результатом работы алгоритма является 
модифицированное АСД программы. 

\begin{figure}[ht] 
  \center
  \includegraphics [scale=0.7] {ast_no_opt}
  \caption{Фрагмент АСД параллельной PGAS программы на языке IBM X10, 
представленной на листинге \ref{list:at_exmpl_no_opt}} 
  \label{img:ast_no_opt}
\end{figure}

Все основные действия алгоритма производится во время рекурсивного обхода АСД в 
глубину. На первом этапе выполняется поиск циклов, содержащих обращения к 
элементам удаленных массивов. Рассмотрим подробнее этот этап. В 
листинге~\ref{list:array_preload_visit} приведен псевдокод функции $Visit$, 
выполняющая рекурсивный обход АСД в глубину. В процессе обхода отыскиваются узлы 
АСД с типом $Loop$, которые соответствуют оператору $for$ 
(листинг~\ref{list:array_preload_visit}, строка 5), и запускается функция 
анализа циклов (листинг~\ref{list:array_preload_visit}, строка 6).

Функция $ProcessLoop$ (листинг~\ref{list:array_preload_process_loop}) выполняет 
проход по всем инструкциям цикла (листинг~\ref{list:array_preload_process_loop}, 
строка 3) с целью поиска узла АСД типа $AtStmt$, который соответствует 
конструкции $at$ (синоним конструкции $on$) передачи управления другому ВУ 
(листинг~\ref{list:array_preload_process_loop}, строка 5). Для получения массива 
поддеревьев, соответствующих дочерним инструкциям, используется функция 
$GetStatements$. В случае обнаружения конструкции $at$ вызывается функция 
$ProcessAtStmt$ (листинг~\ref{list:array_preload_process_loop}, строка 6), 
реализующая поиск операции чтения элементов массива типа $Array$ 
(листинг~\ref{list:array_preload_process_at}). Для упрощения псевдокода в 
листинг~\ref{list:array_preload_process_at} рассматривается случай использования 
удаленных массивов только при объявлении переменных в выражениях инициализации 
($LocalDeclaration$). В общем случае последовательность действий анализа кода, 
выполняющегося на удаленном ВУ, будет зависеть от конкретной программной 
реализации модели PGAS. В процессе анализа инструкции $at$ перебираются все её 
инструкции до тех пор, пока не будет найден узел АСД с типом $LocalDeclaration$ 
(листинг~\ref{list:array_preload_process_at}, строка 3), указывающий на 
локальное объявление переменных. Затем необходимо проверить наличие операций 
чтения элементов массива в выражении инициализации. В описании алгоритма 
предполагается, что обращение к элементу массива выполняется при помощи вызова 
перегруженного оператора круглых скобок.  При помощи функции $GetInitialization$ 
получается узел АСД, соответствующий выражению инициализации объявляемой 
переменной (листинг~\ref{list:array_preload_process_at}, строка 4). Если 
полученный узел имеет тип $Call$ (указывает на вызов метода объекта, 
листинг~\ref{list:array_preload_process_at}, строка 5), а объект -- тип $Array$ 
(листинг~\ref{list:array_preload_process_at}, строка 6), то выражение содержит 
обращение к массиву. На этом завершается первый этап работы алгоритма.

\begin{ListingEnv}[!h]
	\small \VerbatimInput{listings/array_preload_visit.pc}
    \caption{Псевдокод $ArrayPreload$: рекурсивный обход АСД с поиском циклов и 
добавлением пролога цикла}    
    \label{list:array_preload_visit}
\end{ListingEnv}

\begin{ListingEnv}[!h]
	\small \VerbatimInput{listings/array_preload_process_loop.pc}
    \caption{Псевдокод $ArrayPreload$: функция анализа циклов}
    \label{list:array_preload_process_loop}
\end{ListingEnv} 
 
\begin{ListingEnv}[!h]
	\small \VerbatimInput{listings/array_preload_process_at.pc}
    \caption{Псевдокод $ArrayPreload$: функция анализа конструкции $at$}
    \label{list:array_preload_process_at}
\end{ListingEnv} 

На втором этапе (листинг~\ref{list:array_preload_process_at}, строка 7) 
выполняется проверка найденного массива. Для применения оптимизации необходимо 
убедиться в том, что массив не изменяется на протяжении всех итераций цикла, 
иначе применение оптимизации нарушит оригинальную семантику программы. Способ 
проверки неизменяемости массива зависит от реализации компилятора языка, 
например, данная проверка может быть реализована на основе заранее построенного 
контекста каждой инструкции цикла, или на основе контекста цикла целиком. 
Поэтому алгоритм проверки подробно не рассматривается, а используется функция 
$IsReadOnlyArray$, выполняющая её. Функция $IsReadOnlyArray$ возвращает истину, 
если массив не изменяется на протяжении всего цикла, ложь -- в противном случае. 
Функция $GetCallVarName$ возвращает имя объекта, чей метод вызывается.

На третьем этапе выполняется трансформация АСД параллельной программы. В случае 
успешной проверки найденного массива 
(листинг~\ref{list:array_preload_process_at}, строки 5-7) необходимо создать 
пролог цикла, копирующий удаленный массив в память ВУ один раз перед итерациями, 
а также произвести замену чтения удаленного массива на скопированную прологом 
цикла локальную копию. Опережающее копирование можно выполнить различными 
способами, в зависимости от реализации модели PGAS. В работе предложена 
реализация опережающего копирования при помощи использования распределенного 
массива. Достоинством данной реализации является то, что она не требует 
дополнительного расширения модели PGAS. Программист вручную может выполнять 
данные преобразования после тщательного анализа кода программы, но это 
трудоёмко.

Предлагаемая реализация заключается в создании распределенного массива длиной по 
количеству ВУ, элементы которого распределены по одному на каждый ВУ. Каждый 
элемент будет представлять копию удаленного массива. Таким образом, каждый ВУ 
будет хранить локальную копию используемого массива.

\noindent Для создания пролога цикла необходимо:
\begin{enumerate}
	\item Определить позицию оптимизируемого цикла в исходном коде 
(листинг~\ref{list:array_preload_process_at}, строка 8). Это необходимо для 
того, чтобы знать, куда необходимо вставить пролог цикла.
	\item Генерация имени локальной копии массива 
(листинг~\ref{list:array_preload_process_at}, строка 10).
	\item Формирование фрагмента АСД, который соответствует созданию 
распределенного массива для организации опережающего копирования согласно выше 
описанному способу (листинг~\ref{list:array_preload_process_at}, строка 11).
	\item Вставка сформированного фрагмента в заданную позицию АСД программы, а 
именно, перед рассматриваемым циклом 
(листинг~\ref{list:array_preload_process_at}, строка 16). Позиция цикла 
определялась в строке 8.
\end{enumerate}

\noindent После добавления пролога цикла необходимо выполнить замену чтения 
элементов удаленного массива на чтение элементов локальной копии. Для этого 
необходимо: 
\begin{enumerate}
	\item Получить имя локальной копии массива 
(листинг~\ref{list:array_preload_process_at}, строка 10).
	\item Получить список аргументов (листинг~\ref{list:array_preload_process_at}, 
строка 9). Так как обращение к элементу массива -- это вызов перегруженного 
оператора круглых скобок, то аргументом является индекс элемента массива. 
Обращение к локальной копии массива будет производиться по тем же самым 
индексам, что и обращение к удаленному массиву.
	\item Cоздать фрагмент АСД, выполняющий чтение используемых элементов 
локального массива (листинг~\ref{list:array_preload_process_at}, строка 14).
	\item Выполнить замену фрагментов АСД 
(листинг~\ref{list:array_preload_process_at}, строка 15).
\end{enumerate}

Рассмотрим описанные действия на фрагменте АСД из рис.~\ref{img:ast_no_opt}. В 
процессе рекурсивного обхода дерева будет обнаружен узел цикла $for\ (i\ in\ 
0..R)$, имеющий тип $Loop$. Поддерево с корнем, соответствующее циклу $for$, 
передаётся в функцию $ProcessLoop$ для поиска в теле цикла инструкции $at$ 
передачи управления другому ВУ. После обнаружения инструкции $at$ она передается 
в функцию $ProcessAtStmt$ для поиска в ней чтения элементов массива, 
расположенных в памяти удаленного ВУ. Таким массивом является $А$. Массив $А$ не 
изменяется на протяжении всего цикла, а значит можно произвести оптимизацию 
данного участка программы. Для опережающего копирования создаётся распределенный 
массив $localA$, элементами которого является массив $A$. После чего, в 
конструкции $at$ будет использоваться массив $localA$ вместо удаленного массива 
$A$. 

\begin{figure}[ht] 
  \center
  \includegraphics [scale=0.8] {ast_opt}
  \caption{Фрагмент АСД программы на языке IBM X10 после применения 
оптимизирующей трансформации (алгоритм $ArrayPreload$)} 
  \label{img:ast_opt}
\end{figure}

На рис.~\ref{img:ast_opt} приведен фрагмент АСД программы на языке IBM X10 после 
применения оптимизирующей трансформации. Жирным выделены узлы, подвергшиеся 
модификации. Был добавлен пролог цикла $val\ localA: DistArray[Array[Long]]$, а 
также, обращение к массиву $A$ заменено на обращение к массиву $localA$. 

\section{Исследование эффективности алгоритма оптимизация доступа к удаленным 
массивам} \label{sect4_3}

Исследование алгоритмов проводилось на вычислительных кластерах Jet (16 ВУ на 
базе двух четырёхъядерных процессоров Intel Xeon E5420, соединённых сетью 
Gigabit Ethernet) и Oak (6 ВУ на базе двух четырёхъядерных процессоров Intel 
Xeon E5420 соединённых сетью InfiniBand QDR) Центра параллельных вычислительных 
технологий ФГОБУ ВПО «Сибирский государственный университет телекоммуникаций и 
информатики» и Института физики полупроводников им. А.В. Ржанова СО РАН. 
Созданный алгоритм ($ArrayPreload$) программно реализован для языка IBM X10.

Для оценки эффективности алгоритмов $ArrayPreload$ и $Scalar\ replacement$ 
использовался синтетический тест -- циклический доступ к элементам массива, 
расположенным в памяти удаленных ВУ. Компилятор IBM X10 был собран с 
библиотеками MPICH2 3.0.4 (Jet) и MVAPICH2 2.0 (Oak). На 
рис.~\ref{results:arraypreload_scalarreplacement_jet} представлены графики 
зависимости коэффициента ускорения выполнения синтетического теста после 
применения алгоритмов оптимизации ($ArrayPreload$ 
рис.~\ref{results:arraypreload_jet}, $Scalar\ replacement$ 
рис.~\ref{results:scalar_replacement_jet}) от количества $N$ ВУ и числа $R$ 
обращений к массиву на кластере Jet с сетью связи Gigabit Ethernet. На данном 
тесте оба алгоритма демонстрируют ускорение от 5 до 82 раз. 

\begin{figure}[ht]
\centering {
  \begin{minipage}[ht]{0.49\linewidth}\centering 
    \includegraphics[width=1\linewidth]{results_arraypreload_jet} \\ Алгоритм 
    \textit{ArrayPreload}\label{results:arraypreload_jet}
  \end{minipage}
  \hfill       
  \begin{minipage}[ht]{0.49\linewidth}\centering  
    \includegraphics[width=1\linewidth]{results_scalar_replacement_jet} \\ Алгоритм
    \textit{Scalar Replacement}\label{results:scalar_replacement_jet}
  \end{minipage}
1 -- $D$ = 40000, $R$ = 40000; 2 -- $D$ = 40000, $R$ = 4000;\\
3 -- $D$ = 40000, $R$ = 400;   4 -- $D$ = 40000, $R$ = 40;
    \caption{Ускорение тестовой программы (кластер Jet)}
    \label{results:arraypreload_scalarreplacement_jet}
}
\end{figure}

\begin{figure}[ht] 
  \center
  \includegraphics [scale=1] {results_arraypreload_oak} \\
Алгоритм $ArrayPreload$ \\
1 -- $D$ = 40000, $R$ = 40000; 2 -- $D$ = 40000, $R$ = 4000;\\
3 -- $D$ = 40000, $R$ = 400;   4 -- $D$ = 40000, $R$ = 40;
  \caption{Ускорение тестовой программы (кластер Oak)} 
  \label{results:arraypreload_oak}
\end{figure}

На рис.~\ref{results:arraypreload_oak} показаны графики зависимости значения 
коэффициента ускорения выполнения X10-теста от количества $N$ ВУ после 
применения алгоритма $ArrayPreload$ на кластере Oak c сетью связи InfiniBand 
QDR. В ходе экспериментов варьировалось число $R$ обращений к удаленному 
массиву. В общем случае ускорение зависит от производительности коммуникационной 
сети, количества ВУ, размера массива, количества итераций в цикле (в теле 
которого организован циклический доступ).

\todo{Переработать эксперименты ниже}

Для обеспечения минимального суммарного объема передаваемых данных $V$ при
выполнении цикла, необходимо выбирать алгоритм доставки требуемых элементов 
массива в память удаленных ВУ. Выбор алгоритма осуществляется на этапе 
компиляции в зависимости от параметров цикла таких как количество элементов $d$ 
в массиве $a$, количество удаленных ВУ  $m = |M|$ которым передаётся поток 
управления для выполнения на них выделенного фрагмента кода, количество 
используемых элементов $c = |A|$ массива $a$ в выделенном фрагменте кода.

\begin{figure}[ht]
    \center
    \includegraphics [scale=1] {V_from_d} \\
    $r = 40000$ итераций, $m = 40$ ВУ, $c = 156$ элементов; \\
    1 -- алгоритм \textit{Generic}; 2 -- алгоритм \textit{Scalar Replacement}; 
\\
  	3 -- алгоритм \textit{Array Preload}.
    \caption{Зависимость суммарного объема передаваемых данных $V$ от количества 
элементов $d$ в массива $a$}
    \label{results:v_from_d}
\end{figure}

На рис.~\ref{results:v_from_d} показан график зависимости суммарного объема 
передаваемых данных $V$ от размера массива $d$ к элементам которого 
осуществляется доступ в выделенном фрагменте кода. В случае, когда размера 
массива $d$ равен 40000 элементов алгоритм \textit{Array Preload} позволяет в 15
раз сократить объем передаваемых данных по сравнению с алгоритмом \textit{Scalar
Replacement}.

\begin{figure}[ht]
    \center
    \includegraphics [scale=1] {V_from_m} \\
    $r = 40000$ итераций, $m = 40$ ВУ, $c = 156$ элементов; \\
    1 -- алгоритм \textit{Generic}; 2 -- алгоритм \textit{Scalar Replacement}; 
\\
  	3 -- алгоритм \textit{Array Preload}.
    \caption{Зависимость суммарного объема передаваемых данных $V$ от количества
ВУ $m$}
    \label{results:v_from_m}
\end{figure}

\begin{figure}[ht]
    \center
    \includegraphics [scale=1] {V_from_c} \\
    $r = 40000$ итераций, $m = 40$ ВУ, $c = 156$ элементов; \\
    1 -- алгоритм \textit{Generic}; 2 -- алгоритм \textit{Scalar Replacement}; 
\\
  	3 -- алгоритм \textit{Array Preload}.
    \caption{Зависимость суммарного объема передаваемых данных $V$ от количества
используемых элементов массива $c$}
    \label{results:v_from_d}
\end{figure}

\todo{конец текста для экспериментов}

%\newpage
%============================================================================================================================

% \section{Параграф - два} \label{sect3_2}

% Некоторый текст.

%\newpage
%============================================================================================================================

% \section{Параграф с подпараграфами} \label{sect3_3}

%\subsection{Подпараграф - один} \label{subsect3_3_1}

%Некоторый текст.

%\subsection{Подпараграф - два} \label{subsect3_3_2}

%Некоторый текст.

\clearpage

