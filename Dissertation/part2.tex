\chapter{Модель разделенного глобального адресного пространства} \label{chapt4}

Модель разделенного глобального адресного пространства (partitioned global address space -- PGAS) -- это модель параллельного программирования, реализующая общее адресное пространство над распределенной памятью ВС. В модели PGAS доступ из любой ЭМ к глобальному адресному пространству осуществляется как к локальной памяти при помощи высокоуровневых операторов присваивания <<=>>. То есть, модель PGAS позволяет создавать программы для распределенных ВС используя семантику обращения к памяти из ВС с общей памятью. Достоинство данной модели в том, что, в отличие от модели передачи сообщений, в ней отсутствуют коммуникационные операции. Программа, разработанная в модели PGAS называется -- \textit{PGAS-программой}, а язык программирования, реализующий эту модель -- \textit{PGAS-языком}.

\begin{figure}[!h] 
  \center
  \includegraphics [scale=1] {PGAS_model}
  \caption{Отображение модель PGAS на распределенную ВС}
  \label{img:PGAS_model}  
\end{figure}

На рис.~\ref{img:PGAS_model} представлена модель разделенного глобального адресного пространства и её отображение на распределенную ВС из $n$ ЭМ. Ключевым понятием в модели PGAS является \textit{область} (в терминах языка IBM X10 -- \textit{Place}), которая представляет абстракцию ЭМ с разделяемой памятью \todo{на базе многоядерного процессора}. В рамках областей выполняются потоки (в терминах языка IBM X10 -- \textit{Activity}). Данные, над которыми потоки выполняют операции, могут храниться либо в памяти текущей области (\textit{локальной памяти}), либо в памяти другой области (\textit{удаленной памяти}). Память множества областей формирует разделенное глобальное адресное пространство. Доступ ко всем данным в глобальном адресном пространстве осуществляется одинаково без использования коммуникационных операций, вне зависимости от того, где они хранятся, в локальной памяти или удаленной. Каждая область закреплена за определенной ЭМ. Локальная память области является физической памятью ЭМ, а её потоки выполняются процессорными ядрами соответствующей ЭМ.

Реализация модели PGAS определяется PGAS-языком, который предоставляет конструкции для работы с областями (Place) и распределенными по ним данными. Организация разделенного глобального адресного пространства на распределенной по ЭМ памяти осуществляется компилятором и runtime-системой языка. В случае обращения потока одной области к данным, хранимым в удаленной памяти, runtime-система языка организует их доставку при помощи неявного выполнения двусторонних (\textit{дифференцированных}, \textit{point-to-point communications}), односторонних (\textit{one-sided communications}) или коллективных (\textit{collective communications}) коммуникационных операций.

Существующие PGAS-языки делятся на 2 поколения. Языки первого поколения создавались, чтобы объединить преимущества модели $SPMD$ (\textit{SPMD -- single program, multiple data} (\textit{единая программа, множество данных}) и ВС с общей памятью. Одним из таких активно развивающихся языков является $Unified\ Parallel\ C$ (UPC). В листинге~\ref{list:upc_example} показан пример реализации алгоритма умножения матрицы на вектор на языке UPC. Ключевое слово $shared$ используется при объявлении массивов $a$, $b$ и $c$ для того, чтобы сделать их распределенными. Иначе говоря, элементы этих массивов буду блочно храниться в распределенной памяти ВС. Обращение к элементам массива не требует от программиста использовать коммуникационные операции для их доставки из удаленной памяти, эти действия выполняет runtime-система языка, обращения к которой добавляются компилятором.

\begin{ListingEnv}[ht]
	\small \VerbatimInput{listings/upc_example.pc}
    \caption{Пример умножения матрицы на вектор на языке UPC}
    \label{list:upc_example}
\end{ListingEnv}
%добавить ссылку на high-productive
Потребность в современных, удобных и высокоуровневых средствах создания масштабируемых параллельных программ для ВС с распределенной памятью привела к появлению PGAS-языков второго поколения. Эти языки удовлетворяют трем основным требованиям:
\begin{enumerate}
\item Распределенная память ВС представлена в виде единого глобального адресного пространства;
\item Коммуникационные операции используются только runtime-системой языка;
\item Наличие главного потока управления.
\end{enumerate}

К PGAS-языкам второго поколения относятся следующие языки: IBM X10, Cray Chapel, HPF, Sun Fortress и др.. Отличительной особенностью PGAS-языков второго поколения от первого, является то, что они не ограничены использованием модели $SPMD$. Вместо этого, такие языки позволяют параллельную обработку данных за счет выполнения каждой ЭМ независимого потока управления. Такой подход характерен для многопроцессорных ВС с общей памятью.

Выполнение PGAS-программы, разработанной на языке второго поколения, начинается одним потоком управления нулевой области (Place 0). Эта область называется \textit{главной областью}, а ЭМ за которой закреплена нулевая область -- \textit{главной ЭМ}. Остальные области -- подчиненные, а соответствующие им ЭМ -- \textit{подчиненные ЭМ}. Для выполнения параллельной обработки данных, в PGAS-языках второго поколения имеются конструкции порождения новых потоков управления как на текущей ЭМ, так и на удаленных ЭМ. Эти конструкции позволяют выделять участки кода для выполнения в новом потоке на текущей (в IBM X10 конструкция $async$) или на удаленной ЭМ (в IBM X10 конструкция $at$). Конструкция, в которой выделенный участок кода требуется выполнить на подчиненных ЭМ (удаленных ЭМ) называется -- \textit{конструкцией передачи управления подчиненным ЭМ}. 

\begin{ListingEnv}[ht]
	\small \VerbatimInput{listings/x10_example.pc}
    \caption{Фрагмент программы на языке IBM X10 умножения матрицы на вектор}
    \label{list:x10_example}
\end{ListingEnv}

Также как и в PGAS-языках первого поколения, в языках второго поколения предусмотрена возможность прозрачной работы с распределенными массивами. В листинге~\ref{list:x10_example} приведен фрагмент программы на языке IBM X10 умножения матрицы на вектор. В этом примере массив $a$ блоками хранится в распределенной памяти ВС. Массивы $b$ и $c$ созданы в памяти главной ЭМ. При помощи конструкции $at$ осуществляется передача потока управления подчиненной ЭМ в памяти которой хранится $i$-ая строка матрицы $a$. Подчиненная ЭМ выполняет произведение $i$-ой строки матрицы $a$ и вектора $b$. Результат произведения сохраняется в массиве $c$ при помощи глобальной ссылки $c\_ref$.

В модели разделенного глобального адресного пространства отсутствуют коммуникационные операции. При создании PGAS-программ программист использует только языковые конструкции, которые преобразуются PGAS-компилятором в последовательность вызовов функций информационных обменов.

\begin{figure}[!ht] 
  \center
  \includegraphics [scale=1] {PGAS_compilation}
  \caption{Двухэтапный процесс компиляции PGAS-программы}
  \label{img:PGAS_compilation}  
\end{figure}

\begin{figure}[htp]
  \center
  \includegraphics [scale=1] {PGAS_prog_stack}
  \caption{Стек программного обеспечения модели PGAS}
  \label{img:PGAS_prog_stack}  
\end{figure}

Компиляторы основной части языков программирования семейства PGAS является \textit{транспилерами} (\textit{source-to-source compiler}), или транслятором, преобразующим код программы написанный на одном языке в аналогичный код, но на другом языке, как правило C/C++ или Java. На рис.~\ref{img:PGAS_compilation} представлен общий процесс компиляции от PGAS-программ до исполняемого кода или интерпретируемого байт-кода. В общем случае процесс компиляции PGAS-программы содержит 2 этапа. На первом этапе этапе выполняется трансляция PGAS-программы в промежуточный язык. В процессе трансляции компилятор преобразует языковые конструкции в последовательность вызов функций runtime-системы, которые содержат обращения к коммуникационным операциям. В результате генерируется новая \textit{P-программа} в модели передачи сообщений на другом промежуточном языке программирования, как правило, С/С++ или Java. \textit{P-программа} -- это семантически эквивалентное отображение PGAS-программы, разработанной в модели разделенного глобального адресного пространства, на модель передачи сообщений. Трансляция PGAS-программы в P-программа должна обеспечить эффективное использование информационных обменов, так как последние могут привести  к существенным накладным расходам во время выполнения. По этой причине, на данном этапе активно развиваются методы компиляторной оптимизации коммуникационных операций.

На втором этапе выполняется отображение сгенерированной P-программы на целевую архитектуру процессора ЭМ. Данный процесс принято называть \textit{пост-компиляцией}. Для повышения эффективности использования архитектурных возможностей целевого процессора во время пост-компиляции применяются методы оптимизации и автоматической векторизации кода. В результате, генерируется \textit{E-программа}, которая будет запущена на распределенной ВС. E-программа представлена исполняемым кодом или интерпретируемым байт-кодом. В роли пост-компилятора могут выступать промышленные компиляторы GCC, Intel C++ compiler, LLVM/Clang, Javac, PGI, PathScale EKO Compiler Suite и др.

На рисунке~\ref{img:PGAS_prog_stack} представлен общий стек программного обеспечения, необходимый для реализации модели PGAS, от стандартной PGAS-библиотеки до драйвера сетевого устройства. Основными компонентами модели разделенного глобального адресного пространства являются PGAS-компилятор, преобразующий P-программу в E-программу, и runtime-система, выполняющая коммуникационные операции. Реализация runtime-системы может быть основана на библиотеках: стандарта MPI (MPICH2, Open MPI, MVAPICH2, Cray MPI, IBM MPI, Intel MPI и др.), из семейства SHMEM (SGI-SHMEM, MP-SHMEM, LC-SHMEM, Q-SHMEM, HP SHMEM, IBM SHMEM, OpenSHMEM, и др.), либо, может быть уникальное специализированное решение.

\section{Процесс выполнения PGAS-программ в модели передачи сообщений}

В этом разделе рассматривается процесс запуска скомпилированной PGAS-программы, разработанной на PGAS-языке второго поколения, и её выполнение в модели передачи сообщений. Языковые PGAS-конструкции позволяют представить распределенную память ВС в виде единого глобального адресного пространства. В таких языках отсутствует возможность осуществлять явным образом коммуникационные операции. Все информационные обмены между ЭМ выполняются неявно runtime-системой языка. Компилятор языков семейства PGAS транслирует языковые конструкции в
последовательность вызовов функций runtime-библиотеки, которые выполняют информационные обмены между ЭМ. 

Рисунок~\ref{img:PGAS_run} демонстрирует процесс запуска скомпилированной PGAS-программы на ВС с распределенной памятью. E-программа Полученная в результате компиляции исполняемая E-программа копируется на каждую ЭМ и запускается. После запуска на каждой ЭМ создаётся область. На главной ЭМ в рамках области запускается основной поток, который начинает выполнять пользовательский код.

Процесс выполнения PGAS-программы на ВС с распределенной памятью состоит из \todo{фаз} выполнения вычислений и обращения к функциям runtime-системы для управления параллельными процессами и передачи сообщений. Функционирование runtime-системы PGAS-языков второго поколения подобно организации вычислений в модели акторов \ref{}. Акторами, в данном случае, выступают ЭМ, среди которых один актор выделен главным (главная ЭМ или главная область). Информационные обмены осуществляются при помощи функций $Send/Receive$, первый аргумент в которых -- номер принимающей/отправляющей ЭМ, а второй -- отправляемое сообщение. Структура сообщения состоит из полей $type$, $code$ и $data$. Поле $type$ содержит информацию о типе сообщения. Поле $code$ хранит код, который был отправлен для выполнения на текущей ЭМ. Данные, требуемые для выполнения этого кода, хранятся в поле $data$.

Код и используемые данные передаются в \textit{сериализованном} виде, т.е. в виде последовательности байт. В зависимости от реализации runtime-системы языка сериализация может быть выполнена различными способами, например, в случае объектно-ориентированных PGAS-языков код и данные сообщения формируют языковой объект (C++, Java объект), который передаётся в виде последовательности байт. В процедурных PGAS-языках передаваемые участки код могут быть вынесены в отдельные функции, каждой из которых назначается уникальный идентификатор. В этом случае для сериализация кода потребуется найти уникальный идентификатор соответствующей функции, который будет записан в поле $code$ передаваемого сообщения. Так как на главной и подчиненных ЭМ выполняется одна и та же E-программа, принимающая ЭМ сможет найти по идентификатору функцию и вызвать её.

\begin{figure}[!htp] 
  \center
  \includegraphics [scale=1] {PGAS_run}
  \caption{Запуск и выполнение скомпилированной PGAS-программы}
  \label{img:PGAS_run}  
\end{figure}

\begin{figure}[!h]
	\input{listings/runtime_master.pc}
    \caption{Алгоритм работы runtime-системы главной ЭМ}
    \label{list:runtime_master}
\end{figure}

На рисунке~\ref{list:runtime_master} представлен алгоритм работы runtime-системы на главной ЭМ абстрактного PGAS-языка. После запуска PGAS-программы главная ЭМ выполняет следующие основные действия:
\begin{enumerate}
\item Рассылает всем подчиненным ЭМ сообщение с типом $InitMsg$, требующее выполнить инициализацию локальных данных;
\item Выполняет пользовательский код. Пользовательский код может содержать вызовы коммуникационных функций, необходимые для создания распределенных массивов, а также для организации передачи потока управления подчиненным ЭМ. В этом случае сообщение имеет тип $UserCodeMsg$;
\item После завершения выполнения пользовательского кода рассылает всем
  подчиненным ЭМ сообщение с типом $FinalizeMsg$, сигнализирующее о завершении выполнения PGAS-программы.
\end{enumerate}  

\begin{figure}[!h]
	\input{listings/runtime_slave.pc}
    \caption{Алгоритм работы runtime-системы подчиненных ЭМ}
    \label{list:runtime_slave}
\end{figure}

Алгоритм работы runtime-системы подчиненных ЭМ показан на
рисунке~\ref{list:runtime_slave}. Каждая подчиненная ЭМ хранит очередь $q$ принятых сообщений. После запуска PGAS-программы на распределенной ВС подчиненные ЭМ ожидают сообщения инициализации с типом $InitMsg$ от главной ЭМ. Получив данное сообщение ЭМ выполняют инициализацию локальных данных, необходимых для работы runtime-системы. Вновь пришедшие сообщения от главной ЭМ или от подчиненных помещаются в очередь $q$. Подчиненная ЭМ извлекает из очереди сообщение и при помощи функции $ExecuteMsgCode$ выполняет его код, содержащий команды тела конструкции передачи потока управления или команды для создания части распределенного массива в локальной памяти текущей ЭМ. Для выполнения кода сообщения функция $ExecuteMsgCode$ сперва должна десериализовать поля $code$ и $data$. Алгоритм выполняется до тех пор, пока не будет извлечено сообщение с типом $FinalizeMsg$, служащее сигналом завершения выполнения PGAS-программы.

\section{Конструкция передачи потока управления подчиненным ЭМ}

В PGAS-языках второго поколения, таких как IBM X10 и Cray Chapel, присутствует конструкция передачи потока управления от главной ЭМ к подчиненной. В языке
IBM X0 реализована конструкция $at$, в Cray Chapel -- конструкций $on$. Такие
конструкций позволяют выделять в программе участок кода, который требуется
выполнить на указанной ЭМ. Этот участок кода принято называть \textit{телом конструкции}, и именно он в сериализованном виде помещается в поле $code$ сообщения, отправляемого runtime-системой языка.

\begin{ListingEnv}[ht]
	\small \VerbatimInput{listings/x10_at_construction.pc}
    \caption{Пример использования конструкции $at$ на языке $IBM\ X10$}
    \label{list:x10_at_construction}
\end{ListingEnv}

Листинг~\ref{list:x10_at_construction} демонстрирует пример использования
конструкции $at$ передачи потока управления подчиненным ЭМ на языке $IBM\ X10$.
В этом примере осуществляется вызов функции $ComputeSum$ суммирования элементов
массива $a$ на подчиненной ЭМ (удаленной ЭМ). Параметр $world.next(here)$
конструкции $at$ указывает ЭМ которой будет передано управление. Тело
конструкции содержит код, выполняемый указанной ЭМ. В указанном выше примере
тело конструкции содержит вызов функции $ComputeSum$, которой в качестве
аргумента передаётся массив $a$.

Для выполнения тела конструкции передачи потока управления подчиненной ЭМ
необходимо скопировать в память ЭМ код конструкции (функцию $ComputeSum$)
и используемые данные (массив $a$). Для этого, компилятор PGAS-языка преобразует
конструкцию $at$ следующим образом:
\begin{enumerate}
\item Выделяет тело конструкции в отдельную фунцию;
\item Создаёт сообщение, передаваемое подчиненной ЭМ, которое в сериализованном
  виде содержит функцию -- тело конструкции $at$ и используемые данные;
\item Вставляет вызовы коммуникационных функций для отправки созданного
  сообщения подчиненной ЭМ.
\end{enumerate}

\begin{ListingEnv}[ht]
	\small \VerbatimInput{listings/x10_intermediate_at_construction.pc}
    \caption{Пример трансформации конструкции $at$ PGAS-компилятором}
    \label{list:x10_intermediate_at_construction}
\end{ListingEnv}

В листинге~\ref{list:x10_intermediate_at_construction} показан пример
$X10$-подобного промежуточного представления, полученного после преобразования
конструкции $at$ PGAS-компилятором программы, приведенной в
листинге~\ref{list:x10_at_construction}. В результате формируется функция
$BodyAt$, содержащая код тела конструкции $at$, вставлены вызовы функций
сериализации $Serialize$ и функция $Send$ для отправки созданного сообщения
$msg$ подчиненной ЭМ с номером $id$.

\begin{figure}[!h] 
  \center
  \includegraphics [scale=1] {transfer_control}
  \caption{Выполнение конструкции передачи потока управления подчиненной ЭМ}
  \label{img:transfer_control}  
\end{figure}

На рис~\ref{img:transfer_control} изображена интерпретация выполнения
конструкции передачи потока управления подчиненным ЭМ
(листинг~\ref{list:x10_intermediate_at_construction}) в модели передачи
сообщений. Во время выполнения PGAS-программы runtime-система языка при помощи
функции $Serialize$ сериализует код тела конструкции $at$, который на этапе
компиляции преобразован в функцию $BodyAt$. Массив $a$, хранимый в памяти главной ЭМ, также сериализуется в последовательность байт для отправки подчиненной ЭМ с
номером $id$. Результаты сериализации сохраняются в сообщении $msg$, в полях
$code$ и $data$. После завершения формирования сообщения осуществляется его
отправка ЭМ с номером $id$ при помощи функции $Send$.

Принятые сообщения подчиненной ЭМ с номером $id$ сохраняются в очереди $q$.
Runtime-система подчиненной ЭМ извлекает из очереди сообщение $msg$ и при помощи функции $ExecuteMsgCode$ выполняет код сообщения, предварительно выполнив его десериализацию. В данном случае, ЭМ с номером $id$ выполнит отправленную ей функцию $BodyAt$ на массивом $a$.

\section{Конструкция циклической передачи потока управления подчиненным ЭМ}

%% е присутствует конструкция передачи потока управления от
%% главной ЭМ множеству $M$ ЭМ для выполнения ими выделенного фрагмента кода.
%% Правая часть выражений в выделенном фрагменте кода содержит обращения
%% к элементам массива $a$, расположенного в памяти главной ЭМ. Конструкция
%% передачи потока управления подчиненной ЭМ подразумевает доставку в её память
%% выделенного фрагмента кода и используемых данных, которые хранятся в памяти
%% главной ЭМ. В листинге~\ref{list:r_iterations_loop} показан пример подобного
%% шаблона цикла на языке \textit{IBM X10}. Вызов функции $f(a)$ содержит выражения
%% в правой части которых находятся элементы передаваемого в качестве аргумента
%% массива $a$. Примером такой функции может быть реализация алгоритма вычисления
%% суммы всех элементов массива или его части. Для передачи потока управления
%% подчиненной ЭМ с номером $j$, runtime-библиотека языка копирует в её память
%% функцию $f$, которая будет выполниться, и массив $a$, который хранится в памяти
%% главной ЭМ.



%% Перед началом цикла runtime-система языка выбирает алгоритм, определяющий способ
%% доставки массива $a$ в память подчиненных ЭМ, а также  порядок выполнения
%% итераций. Существует два основных алгоритма выполнения цикла. Первый алгоритм
%% \textit{Generic} подразумевает поочередное копирование всего массива $a$
%% в память ЭМ $j$ на каждой итерации цикла. Второй алгоритм осуществляет
%% копирование только используемых элементов массива $a$ в память ЭM $j$.
%% Эти алгоритмы повсеместно используются современными языками, реализующими модель
%% параллельного программирования PGAS, такими как IBM X10 и Cray Chapel (UPC).

Одним из используемых шаблонов в программах, разработанных на PGAS-языках второго поколения, является циклическая конструкция передачи потока управления подчиненным ЭМ.
В этой конструкции присутствует цикл из $r$ итераций. На каждой итерации при помощи конструкции $at$ осуществляется передача потока управления подчиненным ЭМ из множества $M$. На рисунке~\ref{list:r_iterations_loop} представлен пример такого шаблона на языке IBM X10. В этом примере функция $f$ осуществляет доступ к элементам массива $a$.

Наличие таких шаблонов в коде PGAS-программ может послужить источником накладных расходов на коммуникационные операции, необходимые для копирования в память подчиненных ЭМ используемых в теле конструкции данных. Ключевую роль в организация эффективного выполнения конструкций циклической передачи потока управления играет PGAS-компилятор. Во время трансляции PGAS-програмы в P-программу компилятор определяет схему информационных обменов между главной и подчиненными ЭМ.

\begin{ListingEnv}[!htp]
	\small \VerbatimInput{listings/r_iterations_loop.pc}
    \caption{Доступ подчиненных ЭМ к массиву $a$ на языке $IBM\ X10$}
    \label{list:r_iterations_loop}
\end{ListingEnv}


\section{Задача трансформации конструкций циклической передачи потока управления подчиненным ЭМ}

\textit{Постановка задачи}. Имеется параллельная PGAS-программа, которая будет выполняться на распределенной ВС из $n$ ЭМ. В программе присутствует конструкция циклической передачи потока управления подчиненным ЭМ. Цикл конструкции содержит $r$ итераций, на каждой из которых осуществляется передача управления подчиненным ЭМ из множества $M$ при помощи конструкции $at$. \todo{!!!! Всего на каждой итерации выполняется $m = |M|$ передач управления. Всего, на каждой итерации управление передается $m = |M|$ ЭМ.!!!!}

Находящаяся внутри цикла конструкция передачи управления подчиненным ЭМ удовлетворяет следующим требованиям:
\begin{enumerate}
\item В теле конструкции выполняются операции над элементами массивов $a_{0},...a_{l-1}$;
\item Тело конструкции представлено функциями $f_{0}(a_{0}), ..., f_{l-1}(a_{l-1})$, где функция $f_{i}(a_{i})$ содержит операции, выполняемые над элементами массива $a_{i}$
\item Массивы $a_{1}, ..., a_{l-1}$ хранятся в памяти главной ЭМ и не требуют согласования состояния с массивами, скопированными в памяти подчиненных ЭМ.
\end{enumerate}

\begin{ListingEnv}[!h]
  \lstinputlisting[mathescape,
    stepnumber = 1,
    firstnumber=1,
    numberfirstline=true]{listings/task_loop.pc}
    \caption{Пример конструкции удовлетворяющей введенным требованиям на X10-подобном PGAS-языке}
    \label{list:task_loop}
\end{ListingEnv}

В листинге~\ref{list:task_loop} приведен пример конструкции циклической передачи потока управления подчиненным ЭМ, удовлетворяющей приведенным требованиям. Для её выполнения PGAS-компилятор должен отобразить высокоуровневую PGAS-конструкцию на модель передачи сообщений. Иными словами, на этапе компиляции необходимо трансформировать цикл из $r$ итераций, а также добавить вызовы функции runtime-системы языка для организации информационных обменов.

\textit{Требуется}. Разработать алгоритм преобразования циклических конструкций передачи потока управления ЭМ из модели PGAS в модель передачи сообщений.

На вход алгоритма поступает промежуточное представление кода высокоуровневой конструкции циклической передачи потока управления подчиненным ЭМ в модели PGAS, представленное абстрактным синтаксическим деревом (АСД). Во время компиляции алгоритм трансформирует цикл, преобразует конструкцию передачи потока управления в последовательность вызовов функций runtime-библиотеки для копирования функций $f_{0},...,f_{l-1}$ и доставки массивов $a_{0},...,a_{l-1}$ в память подчиненных ЭМ. Таким образом, результатом работы алгоритма является модифицированная программа в модели передачи сообщений.

%% Во время выполнения скомпилированной PGAS-программы runtime-библиотека копирует используемые массивы в память подчиненных ЭМ при помощи односторонних, дифференцированных или коллективных информационных обменов.

\section{Алгоритмы трансформации конструкций циклической передачи потока управления подчиненным ЭМ}

Во передачи потока управления подчиненным ЭМ runtime-система при помощи информационных обменов выполняет копирование требуемых данных в память удаленной ЭМ. Обращения к функция runtime-системы для выполнения коммуникационных операций добавляются PGAS-компилятором во время преобразования PGAS-программы в P-программу модели передачи сообщений.

Для трансформации конструкций циклической передачи потока управления подчиненным ЭМ в модель передачи сообщений компиляторы PGAS-языков второго поколения широко используют алгоритм -- \textit{By iterative copying}, который генерирует обращения к функциям коммуникационных операций на каждой итерации цикла. Этот алгоритм не требует сложного анализа промежуточного представления тела конструкции на этапе компиляции программы, так как используемые массивы передаются подчиненным ЭМ из множества $M$ на каждой итерации $i=\{0..r-1\}$. Достоинством данного алгоритма является универсальность его использования, т.е. он применим к конструкциям всех возможных видов. Однако, существенный недостаток этого алгоритма заключается в том, что избыточное копирование всех элементов используемых массивов $a_{0},...,a_{l-1}$ на каждой итерации приведет к существенным накладным расходам во время выполнения PGAS-программы.

Для сокращения накладных расходов на избыточное копирование элементов массивов в память подчиненных ЭМ предложен алгоритм \textit{Scalar Replacement}. Во время трансформации циклической конструкции передачи потока управления алгоритм  добавляет вызовы коммуникационных операций для отправки только используемых элементов массивов $a_{0},...,a_{l-1}$, а не всех целиком, как в случае использования алгоритма \textit{By iterative copying}. Подобная трансформация кода циклической конструкции требует дополнительных действий на этапе статического анализа промежуточного представления PGAS-программы, так как необходимо определить индексы используемых элементов. Недостатком этого алгоритма является ограниченность его применения, а именно, алгоритм не применим в случае, если на этапе статического анализа промежуточного представления PGAS-программы не представляется возможным определить значения индексов используемых
элементов массивов $a_{0},...,a_{l-1}$.


Сократить накладные расходы на избыточное копирование массивов $a_{0},...,a_{l-1}$ в память подчиненных ЭМ, но при этом избежать недостатки алгоритма \textit{Scalar Replacement} позволяет предложенный алгоритм опережающего копирования -- \textit{Array Preload}. Данный алгоритм выполняет преобразование циклической конструкции после которого копирование массивов $a_{0},...,a_{l-1}$ в удаленную память подчиненных ЭМ происходит только один раз перед итерациями цикла. Так как массивы копируются целиком, а не только используемые элементы,
алгоритм может быть применим в тех случаях, когда на этапе статического анализа кода PGAS-программы невозможно определить значения индексов используемых элементов. Недостатком алгоритма \textit{Array Preload} является необходимость на этапе компиляции производить существенную трансформацию конструкции циклической передачи управления подчиненной ЭМ, так как необходимо добавить пролог цикла и изменить обращения к массивам $a_{0},...,a_{l-1}$ в функциях $f_{0},...,f_{l-1}$.

\todo {
  Добавить таблицу сравнения алгоритмов.
}

\subsection{Алгоритм \textit{By-iterative copying} трансформации конструкций произвольной формы}

В компиляторах PGAS-языков второго поколения, таких как IBM X10 и Cray Chapel, для трансформации конструкций циклической передачи потока управления подчиненным ЭМ большое распространение получил алгоритм \textit{By-iterative copying}, так как область его применимости не ограничена формой конструкции. Этот алгоритм преобразует цикл так, что во время его выполнения на каждой итерации происходят информационные обмены для доставки требуемых данных в память удаленной ЭМ. На рисунке~\ref{list:p-program_default} приведен фрагмент P-программы, полученный после трансформации PGAS-программы (рисунок~\ref{list:task_loop}) алгоритмом \textit{By-iterative copying}. В результате трансформации тело конструкции $at$ преобразовано в функцию $BodyAt$, а в тело цикла добавлен код для создания сообщения $msg$ и его отправки ЭМ с номером $j$.

\begin{ListingEnv}[!ht]
  \input{listings/p-program_default.pc}
    \caption{Фрагмент P-программы после применения к PGAS-программе алгоритма \textit{By-iterative copying} трансформации циклической конструкции передачи потока управления подчиненным ЭМ}
    \label{list:p-program_default}
\end{ListingEnv}

\begin{figure}[!ht]
	\input{listings/default_transformation.pc}
    \caption{Алгоритм \textit{By-iterative copying} трансформации конструкций произвольной формы}
    \label{list:default_transformation}
\end{figure}

\begin{figure}[!hb] 
  \center
  \includegraphics [scale=1] {AST_PGAS_construction}
  \caption{Фрагмент АСД, отображающего циклическую конструкцию передачи потока управления подчиненным ЭМ}
  \label{img:AST_PGAS_construction}
\end{figure}

\begin{figure}[!ht] 
  \center
  \includegraphics [scale=1] {AST_default_BodyAt}
  \caption{Фрагмент АСТ, которому соответствует функция \textit{BodyAt}, сформированная алгоритмом \textit{By-iterative copying}}
  \label{img:AST_default_BodyAt}
\end{figure}

На рисунке~\ref{list:default_transformation} приведен псевдокод алгоритма \textit{By-iterative copying}. На вход алгоритма поступает абстрактное синтаксическое дерево $C$ (рисунок~\ref{img:AST_PGAS_construction}) конструкции циклической передачи потока управления подчиненным ЭМ из множества $M$. На выходе формируется модифицированное АСД $C^{\prime}$ (рисунок~\ref{img:AST_default_transformed}) конструкции, а также АСД $P$ (рисунок~\ref{img:AST_default_BodyAt}) отображающее функцию $BodyAt$. Алгоритм состоит из 7 основных шагов:
\begin{enumerate}
\item Поиск в АСД $C$ поддерева $B$, которому сопоставлено тело внутреннего цикла, на итерациях которого осуществляется передача потока управления подчиненным ЭМ при помощи конструкции $at$. Поиск выполняет функция $LookupInnerLoopBody$;
\item Поиск в АСД $C$ узла $r$, которому сопоставлен номер удаленной ЭМ $j$. Поиск осуществляется при помощи функции $LookupIdRemoteNode$;
\item Поиск в АСД $B$ и формирование последовательности узлов $(a_{0},...,a_{l-1})$, которые отображают массивы, чьи элементы используются внутри тела конструкции $at$. Для этого используется функция $LookupArrays$, принимающая в качестве входного аргумента корень АСД $B$ тела внутреннего цикла;
\item Поиск в АСД $B$ и формирование последовательности узлов $(f_{0},...,f_{l-1})$, которым соответствуют функции, содержащие операции работы с элементами массивов $a_{0},...,a_{l-1}$. Поиск выполняется при помощи функции $LookupOperators$, принимающей на вход корень АСД $B$ и список узлов $(a_{0},...,a_{l-1})$ АСД.
\item Построение АСД $P$ отображающее функцию $BodyAt$. Для построения дерева используется функция $BuildTreeBodyAt$. На рисунке~\ref{img:AST_default_BodyAt} показан пример результирующего на данном шаге АСД.
\item Формирование модифицированного АСД $B^{\prime}$ которое соответствует телу цикла P-программы в модели передачи сообщений. Модифицированное АСД содержит узлы, которым сопоставлен код для формирования сообщения $msg$ и отправки его ЭМ с номером $j$. Эти действия выполняются функцией $BuildASTSendMsg$;
\item Замена в АСД $C$ поддерева $B$ тела внутреннего цикла PGAS-программы на поддерево $B^{\prime}$ преобразованного тела этого же цикла P-программы. Замена производится при помощи функции $ReplaceAST$. В результате формируется модифицированное АСТ $C^{\prime}$ конструкции в модели передачи сообщений для P-программы. На рисунке~\ref{img:AST_default_transformed} приведено результирующее АСТ $C^{\prime}$ после всех преобразований алгоритма.
\end{enumerate}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {AST_default_transformed}
  \caption{Фрагмент АСД конструкции циклической передачи потока управления подчиненным ЭМ, полученный после трансформации алгоритмом \textit{By-iterative copying}}
  \label{img:AST_default_transformed}
\end{figure}

\subsection{Алгоритм \textit{Scalar Replacement} трансформации конструкций с обращением к определенным элементам массивов}

Параллельные PGAS-программы могут содержать конструкции циклической передачи управления подчиненным ЭМ, в которых используются элементы массивов с заранее известными значениями индексов, либо их можно определить на этапе компиляции. Для сокращения накладных расходов на передачу используемых данных в таких программах компиляторы для PGAS-языков второго поколения (IBM X10, Cray Chapel), реализуют алгоритм \textit{Scalar Replacement}. Этот алгоритм преобразует конструкции циклической передачи управления подчиненным ЭМ PGAS-программы, при её отображении на модель передачи сообщений, таким образом,
чтобы в память удаленных ЭМ копировались только используемые элементы массивов $a_{0},...,a_{l-1}$, а не все, как в случае использования \textit{By-iterative copying}.

\begin{ListingEnv}[!h]
  \input{listings/p-program_scalar_replacement.pc}
    \caption{Фрагмент P-программы после применения к PGAS-программе алгоритма \textit{Scalar Replacement} трансформации циклической конструкции передачи потока управления подчиненным ЭМ}
    \label{list:p-program_scalar_replacement}
\end{ListingEnv}

Алгоритм \textit{Scalar Replacement} подразумевает, что на этапе компиляции возможно определить множество $T=\{t_{0},...,t_{q-1}\}$ используемых элементов массивов $a_{0},...,a_{l-1}$, где $t_{i} \in a_{j}, 0 \leq j \leq l-1$ и последовательность $(g_{0},...,g_{q-1})$ операций над ними. На рисунке~\ref{list:p-program_scalar_replacement} представлен фрагмент P-программы, которая является отображением PGAS-программы из рисунка~\ref{list:task_loop} на модель передачи сообщений, после преобразований алгоритмом \textit{Scalar Replacement}. В результате преобразований все используемые элементы массивов, собранные во множестве $T$, будут на каждой итерации $i$ копироваться в память удаленных ЭМ с номером $j$. Тело конструкции $at$, представленное функцией $BodyAt$, также подверглось трансформации, а именно, после преобразований оно содержит не функции $f_{0},...f_{l-1}$ операций над массивами $a_{0},...,a_{l-1}$, а функции $g_{0},..,g_{q-1}$ операций над элементами из множества $T$.

На рисунке~\ref{list:scalar_replacement_transformation} приведен псевдокод алгоритма \textit{Scalar Replacement}. На вход алгоритма поступает абстрактное синтаксическое дерево $C$ (рисунок~\ref{img:AST_PGAS_construction}) конструкции циклической передачи потока управления подчиненным ЭМ из множества $M$. На выходе формируется модифицированное алгоритмом АСД $C^{\prime}$ (рисунок~\ref{img:AST_scalar_replacement_transformed}) конструкции, а также АСД $P$ (рисунок~\ref{img:AST_scalar_replacement_BodyAt}) представляющее функцию $BodyAt$. Алгоритм состоит из 7 основных шагов:
\begin{enumerate}
\item Поиск в АСД $C$ поддерева $B$, которому соответствует тело внутреннего цикла;
\item Поиск в АСД $B$ узла $r$, соответствующего номерам подчиненных ЭМ, которым конструкция $at$ передаст управление во время выполнения;
\item Поиск в АСД $B$ поддерева $A$, содержащего узлы, формирующие тело конструкции $at$. На рисунке~\ref{img:AST_scalar_replacement_at} изображен пример такого АСД;
\item Поиск в теле конструкции $at$ используемых элементов массивов $a_{1},...,a_{l-1}$ и формирование множества $T$ из найденных элементов;
\item Поиск в теле конструкции $at$ операторов, выполняющих действия над элементами массивов из множества $T$, и формирование из них последовательности $(g_{0},...,g_{q-1})$;
\item Построение АСД $P$, которое представляет функцию $BodyAt$, содержащую трансформированное тело конструкции $at$. В результате преобразований функции $f_{0},...f_{l-1}$ с операциями над массивами $a_{0},...,a_{l-1}$ заменяются на операторы $(g_{0},...,g_{q-1})$ с операндами из множества $T$;
\item Построение модифицированного АСД $B^{\prime}$, соответствующего циклической конструкции, содержащей код создания и отправки сообщения $msg$.
\end{enumerate}

\begin{figure}[!hb]
	\input{listings/scalar_replacement_transformation.pc}
    \caption{Алгоритм \textit{Scalar Replacement} трансформации конструкций c обращением к определенным элементам массивов}
    \label{list:scalar_replacement_transformation}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {AST_scalar_replacement_at}
  \caption{Фрагмент АСД циклической передачи потока управления подчиненным ЭМ с развернутым телом конструкции \textit{at}}
  \label{img:AST_scalar_replacement_at}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {AST_scalar_replacement_BodyAt}
  \caption{Фрагмент АСТ, которому соответствует функция \textit{BodyAt}, сформированная алгоритмом \textit{Scalar Replacement}}
  \label{img:AST_scalar_replacement_BodyAt}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {AST_scalar_replacement_transformed}
  \caption{Фрагмент АСД конструкции циклической передачи потока управления подчиненным ЭМ, полученный после трансформации алгоритмом \textit{Scalar Replacement}}
  \label{img:AST_scalar_replacement_transformed}
\end{figure}

\subsection{Алгоритм \textit{Array Preload} трансформации конструкций для выполнения опережающего копирования массивов}

Идея алгоритма \textit{Array Preload} заключается в преобразовании конструкции циклической передачи потока управления подчиненным ЭМ таким образом, чтобы при выполнении PGAS-программы копирование используемых данных в память удаленных ЭМ осуществлялось только 1 раз пред циклом, а не на каждой итерации $i$. Такой подход принято называть \textit{опережающем копированием массивов} (\textit{preemptive copying}).

Опережающее копирование массивов в удаленную память подчиненных ЭМ выполняется прологом цикла. Основные преобразования, выполняемые алгоритмом \textit{Array Preload}, направлены на формирование пролога цикла для отправки подчиненным ЭМ используемых массивов и создания их локальных копий в памяти ЭМ, а также на преобразование тела конструкции передачи управления. В ходе преобразований тела конструкции обращения к массиву, расположенному в памяти главной ЭМ, заменяются на обращения к его локальной копии, созданной в памяти подчиненных ЭМ.

На рисунке~\ref{list:p-program_array_preload} показан фрагмент P-программы, полученный алгоритмом \textit{Array Preload}. В результате применения алгоритма была добавлена функция $PrologueBody$, создающая локальные копии массивов, пролог цикла, выполняющий отправку сообщений удаленным ЭМ, и модифицирована функция $BodyAt$, в которой обращения к массивам $a_{0},...,a_{l-1}$ заменены на обращения к их локальным копиям $a^{\prime}_{l-1}$, $a_{l-1}$. Таким образом, отправка массивов $a_{0},...,a_{l-1}$ ЭМ из множества $M$ на каждой итерации $i$ не требуется.

На рисунке~\ref{list:array_preload_transformation} показан псевдокод алгоритма \textit{Array Preload}. На вход алгоритма подаётся АСД $C$ конструкции циклической передачи потока управления подчиненным ЭМ из множества $M$ (рисунок~\ref{img:AST_PGAS_construction}). На выходе алгоримт формирует АСД $C^{\prime}$ (рисунок~\ref{img:AST_array_preload_transformed}) конструкции, АСД $P$ (рисунок~\ref{img:AST_array_preload_BodyAt}) функции $BodyAt$ и АСД $H$, представляющее функцию для создания локальных копий массивов в памяти подчиненных ЭМ. Алгоритм состоит из 9 шагов, первые 4 шага выполняют те же действия, что и алгоритм \textit{By-iterative copying}. Оставшиеся 5 шагов выполняют:
\begin{enumerate}
\item Построение АСД $H$ функции $PrologueBody$ (рисунок~\ref{img:AST_array_preload_prologuebody}), выполняющей создание локальных копий массивов $a_{0},...,a_{l-1}$ в памяти подчиненных ЭМ;
\item Поиск множества массивов $\{a^{\prime}_{l-1}$, $a_{l-1}\}$, созданных в локальной памяти подчиненных ЭМ;
\item Построение АСД $S$ (рисунок~\ref{img:AST_array_preload_prologue_loop}), соответствующего прологу цикла, который выполняет отправку сообщения подчиненным ЭМ для создания в их памяти локальных копий используемых массивов;
\item Построение АСД $P$ функции $BodyAt$ (рисунок~\ref{img:AST_array_preload_BodyAt}), соответствующей телу конструкции передачи управления подчиненным ЭМ;
\item Преобразования АСД $B$ циклической конструкции передачи управления подчиненным ЭМ в АСД $B^{\prime}$ (рисунок~\ref{img:AST_array_preload_transformed}), содержащее узлы для отправки сообщения.
\end{enumerate}

\begin{figure}[!ht]
	\input{listings/array_preload_transformation.pc}
    \caption{Алгоритм \textit{Array Preload} трансформации конструкций для выполнения опережающего копирования массивов}
    \label{list:array_preload_transformation}
\end{figure}

\begin{ListingEnv}[!ht]
  \input{listings/p-program_array_preload.pc}
    \caption{Фрагмент P-программы после применения к PGAS-программе алгоритма \textit{Array Preload} трансформации циклической конструкции передачи потока управления подчиненным ЭМ}
    \label{list:p-program_array_preload}
\end{ListingEnv}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {AST_array_preload_prologuebody}
  \caption{Фрагмент АСД $H$ функции $PrologueBody$ создания локальных копий массивов $a_{0},..a_{l-1}$ в памяти удаленных ЭМ}
  \label{img:AST_array_preload_prologuebody}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {AST_array_preload_prologue_loop}
  \caption{Фрагмент АСД $S$, соответствующего прологу цикла для опережающего копирования массивов $a_{0},..a_{l-1}$ в память удаленных ЭМ}
  \label{img:AST_array_preload_prologue_loop}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {AST_array_preload_BodyAt}
  \caption{Фрагмент АСД, которому соответствует функция \textit{BodyAt}, сформированная алгоритмом \textit{Array Preload}}
  \label{img:AST_array_preload_BodyAt}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {AST_array_preload_transformed}
  \caption{Фрагмент АСД конструкции циклической передачи потока управления подчиненным ЭМ, полученный после трансформации алгоритмом \textit{Array Preload}}
  \label{img:AST_array_preload_transformed}
\end{figure}

\clearpage

\section{Анализ эффективности копирования массивов в память подчиненных ЭМ при выполнении P-программы}

Описанные выше алгоритмы трансформации конструкций циклической передачи потока управления подчиненным ЭМ из множества $M$ преобразуют высокоуровневые конструкции PGAS-программы в последовательность вызовов функций runtime-системы P-программы. В этом разделе выполнен анализ эффективности кода P-программы для доставки используемых массивов подчиненным ЭМ, полученного в результате применения описанных алгоритмов. Кроме этого, для каждого алгоритма построены оценки времени выполнения в моделях Хокни, LogP и LogGP.

Алгоритм \textit{By Iterative Copying} преобразует конструкцию циклической передачи потока управления подчиненным ЭМ из множества $M$ таким образом, что при выполнении P-программы на каждой итерации конструкции каждой подчиненной ЭМ будут передаваться все используемые массивы $a_{0},...,a_{l-1}$. В этом случае главной ЭМ на каждой итерации потребуется отправить $V$ байт: 
\[ V = m \cdot \sum \limits_{i=0}^{l-1} s_{i} \cdot b,\]
где $b$ -- размер одного элемента массива в байтах.

\begin{figure}[!h] 
  \center
  \includegraphics [scale=1] {default_logP}
  \caption{Пространственно-временная диаграмма информационных обменов в модели LogP при выполнении циклической конструкции передачи потока управления подчиненным ЭМ, преобразованной алгоритмом \textit{By-iterative copying}}
  \label{img:default_logP}
\end{figure}

\begin{figure}[!h] 
  \center
  \includegraphics [scale=1] {default_logGP}
  \caption{Пространственно-временная диаграмма информационных обменов в модели LogGP при выполнении циклической конструкции передачи потока управления подчиненным ЭМ, преобразованной алгоритмом \textit{By-iterative copying}}
  \label{img:default_logGP}
\end{figure}

Эффективность преобразований, выполняемых алгоритмом \textit{By-iterative copying}, определяется временем, затраченным на доставку используемых массивов в память подчиненных ЭМ при выполнении P-программы. Пространственно-временная диаграмма информационных обменов в модели LogP и LogGP при выполнении P-программы представлена на рисунках~\ref{img:default_logP},~\ref{img:default_logGP}. Время $t$ выполнения конструкции, в модели LogP, LogGP и Hockney будет равно:
\[ t_{logP} = g \cdot m \cdot r - g + L + 2 \cdot o\]
\[ t_{logGP} = ((\sum \limits_{i=0}^{l-1} s_{i} \cdot b-1)\cdot G + g)\cdot m \cdot r - g + L + 2 \cdot o =\]
\[= ((\frac{V}{m}-1)\cdot G + g)\cdot m \cdot r - g + L + 2 \cdot o\]
\[ t_{Hockney} = r \cdot m \cdot (\alpha + \beta \cdot \sum \limits_{i=0}^{l-1} s_{i} \cdot b) = r \cdot m \cdot (\alpha + \beta \cdot \frac{V}{m}).\]

Алгоритм \textit{Scalar Replacement} выполняет преобразование конструкции циклической передачи потока управления подчиненным ЭМ таким образом, чтобы во время её выполнения в P-программе главная ЭМ на каждой итерации отправляла только используемых элементы массивов. В этом случае главной ЭМ на каждой итерации потребуется отправить $V$ байт:
\[ V = m \cdot q \cdot b,\]
где $b$ -- размер одного элемента массива в байтах. А время $t$ выполнения конструкции, в моделях LogP, LogGP и Hockney будет равно:
\[ t_{logP} = g \cdot m \cdot r - g + L + 2 \cdot o\]
\[ t_{logGP} = ((q \cdot b - 1)\cdot G + g)\cdot m \cdot r - g + L + 2 \cdot o = \]
\[ = ((\frac{V}{m}-1)\cdot G + g)\cdot m \cdot r - g + L + 2 \cdot o\]
\[ t_{Hockney} = r \cdot m \cdot (\alpha + \beta \cdot q \cdot b) = \]
\[ = r \cdot m \cdot (\alpha + \beta \cdot \frac{V}{m}).\]

При выполнении циклических конструкций передачи потока управления подчиненным ЭМ в P-программе, формируемой с применением алгоритма \textit{Array Preload}, копирование массивов $a_{0},...,a_{l-1}$ в удаленную память ЭМ происходит только 1 раз перед итерациями в прологе цикла. Поэтому, главная ЭМ на каждой итерации отправляет $V$ байт:
\[ V = m \cdot \sum \limits_{i=0}^{l-1} s_{i} \cdot b,\]
где $b$ -- размер одного элемента массива в байтах. Время $t$ выполнения пролога цикла и самой конструкции в моделях LogP, LogGP и Hockney будет иметь следующий вид:
\[ t_{LogP} = g \cdot m - g + L + 2 \cdot o\]
\[ t_{LogGP} = (((\sum \limits_{i=0}^{l-1} s_{i} \cdot b)-1)\cdot G + g)\cdot m - g + L + 2 \cdot o = \]
\[ = ((\frac{V}{m}-1)\cdot G + g)\cdot m - g + L + 2 \cdot o\]
\[ t_{Hockney} = m \cdot (\alpha + \beta \cdot \sum \limits_{i=0}^{l-1} s_{i} \cdot b) = \]
\[ = m \cdot (\alpha + \beta \cdot \frac{V}{m}).\]

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {t_r_bic}
  \caption{Зависимость времени выполнения копирования массивов в память подчиненных ЭМ при выполнении P-программы, полученной алгоритмом \textit{By Iterative Copying}, от числа $r$ итераций в циклической конструкции передачи потока управления}
  \label{graph:t_r_bic}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {t_r_sr}
  \caption{Зависимость времени выполнения копирования массивов в память подчиненных ЭМ при выполнении P-программы, полученной алгоритмом \textit{Scalar Replacement}, от числа $r$ итераций в циклической конструкции передачи потока управления}
  \label{graph:t_r_sr}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {t_r_ap}
  \caption{Зависимость времени выполнения копирования массивов в память подчиненных ЭМ при выполнении P-программы, полученной алгоритмом \textit{Array Preload}, от числа $r$ итераций  в циклической конструкции передачи потока управления}
  \label{graph:t_r_ap}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {t_m_bic}
  \caption{Зависимость времени выполнения копирования массивов в память подчиненных ЭМ при выполнении P-программы, полученной алгоритмом \textit{By Iterative Copying}, от количества $m$ подчиненных ЭМ, которым передаётся управление}
  \label{graph:t_m_bic}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {t_m_sr}
  \caption{Зависимость времени выполнения копирования массивов в память подчиненных ЭМ при выполнении P-программы, полученной алгоритмами \textit{Scalar Replacement} -- 1,2 и \textit{Array Preload} -- 3, от количества $m$ подчиненных ЭМ, которым передаётся управление}
  \label{graph:t_m_sr}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {t_s_bic}
  \caption{Зависимость времени выполнения копирования массивов в память подчиненных ЭМ при выполнении P-программы, полученной алгоритмами \textit{By Iterative Copying}, от размера $s$ массива, доступ к которому осуществляется подчиненными ЭМ}
  \label{graph:t_s_bic}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {t_s_sr}
  \caption{Зависимость времени выполнения копирования массивов в память подчиненных ЭМ при выполнении P-программы, полученной алгоритмами \textit{Scalar Replacement}, от размера $s$ массива, доступ к которому осуществляется подчиненными ЭМ}
  \label{graph:t_s_sr}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {t_s_ap}
  \caption{Зависимость времени выполнения копирования массивов в память подчиненных ЭМ при выполнении P-программы, полученной алгоритмами \textit{Array Preload}, от размера $s$ массива, доступ к которому осуществляется подчиненными ЭМ}
  \label{graph:t_s_ap}
\end{figure}

\clearpage

\section{Экспериментальное исследование эффективности доставки массивов в удаленную память подчиненных ЭМ} \label{sect4_3}

Экспериментальное исследование алгоритмов проводилось на вычислительных кластерах Jet (16 ЭМ на базе двух четырёхъядерных процессоров Intel Xeon E5420, соединённых сетью 
Gigabit Ethernet) и Oak (6 ЭМ на базе двух четырёхъядерных процессоров Intel 
Xeon E5420 соединённых сетью InfiniBand QDR) Центра параллельных вычислительных 
технологий ФГОБУ ВПО «Сибирский государственный университет телекоммуникаций и 
информатики» и Института физики полупроводников им. А.В. Ржанова СО РАН. 
Предложенный алгоритм \textit{Array Preload} программно реализован для языка IBM X10.

Для оценки эффективности алгоритмов \textit{By Iterative Copying}, \textit{Scalar Replacement} и \textit{Array Preload} использовался синтетический тест -- циклический доступ к одному элементу массива типа double ($b$~=~8), расположенного в памяти главной ЭМ. Компилятор IBM X10 был собран с библиотеками MPICH2 3.0.4 (Jet) и MVAPICH2 2.0 (Oak). На рисунках~\ref{graph:sr_jet_S_m_r},~\ref{graph:ap_jet_S_m_r} представлены графики зависимости коэффициента ускорения выполнения синтетического теста на ВС с сетью связи Gigabit Ethernet после применения алгоритмов \textit{Scalar Replacement} и \textit{Array Preload}. На рисунках~\ref{graph:sr_jet_S_m_r},~\ref{graph:ap_jet_S_m_r} показана зависимость коэффициента ускорения выполнения теста на ВС с сетью связи Gigabit Ethernet, трансформированного алгоритмами \textit{Scalar Replacement} и \textit{Array Preload} от числа $m$ подчиненных ЭМ при различных значениях размера массива $s$ и числа итераций $r$.

На рисунках~\ref{graph:ap_oak_S_m_r},~\ref{graph:ap_oak_S_m_s} представленные графики зависимости коэффициента ускорения выполнения тестовой программы на ВС с сетью связи InfiniBand QDR, полученной с применением алгоритма \textit{Array Preload}, от числа $m$ подчиненных ЭМ при варьирующихся значениях размера массива $s$ (рисунок~\ref{graph:ap_oak_S_m_s}) и числа итераций $r$ (рисунок~\ref{graph:ap_oak_S_m_r}).

На данном тесте оба алгоритма демонстрируют ускорение от 5 до 82 раз при выполнении на ВС с сетью связи Gigabit Ethernet. Во время экспериментов на ВС с сетью связи  ВС InfiniBand QDR было достигнуто ускорение от 2 до 7 раз.

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {sr_jet_S_m_r} \\
1 -- $s$ = 40000, $r$ = 40000; 2 -- $s$ = 40000, $r$ = 4000;\\
3 -- $s$ = 40000, $r$ = 400;   4 -- $s$ = 40000, $r$ = 40;
  \caption{Ускорение тестовой программы на языке IBM X10, скомпилированной с применением алгоритма \textit{Scalar Replacement} (кластер Jet)}
  \label{graph:sr_jet_S_m_r}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {sr_jet_S_m_s} \\
1 -- $s$ = 40000, $r$ = 4000; 2 -- $s$ = 4000, $r$ = 4000;\\
3 -- $s$ = 400,   $r$ = 4000; 4 -- $s$ = 40,   $r$ = 4000;
  \caption{Ускорение тестовой программы на языке IBM X10, скомпилированной с применением алгоритма \textit{Scalar Replacement} (кластер Jet)}
  \label{graph:sr_jet_S_m_s}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {ap_jet_S_m_r} \\
1 -- $s$ = 40000, $r$ = 40000; 2 -- $s$ = 40000, $r$ = 4000;\\
3 -- $s$ = 40000, $r$ = 400;   4 -- $s$ = 40000, $r$ = 40;
  \caption{Ускорение тестовой программы на языке IBM X10, скомпилированной с применением алгоритма \textit{Array Preload} (кластер Jet)}
  \label{graph:ap_jet_S_m_r}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {ap_jet_S_m_s} \\
1 -- $s$ = 40000, $r$ = 4000; 2 -- $s$ = 4000, $r$ = 4000;\\
3 -- $s$ = 400,   $r$ = 4000; 4 -- $s$ = 40,   $r$ = 4000;
  \caption{Ускорение тестовой программы на языке IBM X10, скомпилированной с применением алгоритма \textit{Array Preload} (кластер Jet)}
  \label{graph:ap_jet_S_m_s}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {ap_oak_S_m_r} \\
1 -- $s$ = 40000, $r$ = 40000; 2 -- $s$ = 40000, $r$ = 4000;\\
3 -- $s$ = 40000, $r$ = 400;   4 -- $s$ = 40000, $r$ = 40;
  \caption{Ускорение тестовой программы на языке IBM X10, скомпилированной с применением алгоритма \textit{Array Preload} (кластер Oak)}
  \label{graph:ap_oak_S_m_r}
\end{figure}

\begin{figure}[!h]
  \center
  \includegraphics [scale=1] {ap_oak_S_m_s} \\
1 -- $s$ = 40000, $r$ = 4000; 2 -- $s$ = 4000, $r$ = 4000;\\
3 -- $s$ = 400,   $r$ = 4000; 4 -- $s$ = 40,   $r$ = 4000;
  \caption{Ускорение тестовой программы на языке IBM X10, скомпилированной с применением алгоритма \textit{Array Preload} (кластер Oak)}
  \label{graph:ap_oak_S_m_s}
\end{figure}

\begin{figure}[ht]
\centering {
  \begin{minipage}[ht]{0.49\linewidth}\centering 
    \includegraphics[width=1\linewidth]{results_arraypreload_jet} \\ Алгоритм 
    \textit{ArrayPreload}\label{results:arraypreload_jet}
  \end{minipage}
  \hfill       
  \begin{minipage}[ht]{0.49\linewidth}\centering  
    \includegraphics[width=1\linewidth]{results_scalar_replacement_jet} \\ Алгоритм
    \textit{Scalar Replacement}\label{results:scalar_replacement_jet}
  \end{minipage}
1 -- $D$ = 40000, $R$ = 40000; 2 -- $D$ = 40000, $R$ = 4000;\\
3 -- $D$ = 40000, $R$ = 400;   4 -- $D$ = 40000, $R$ = 40;
    \caption{Ускорение тестовой программы (кластер Jet)}
    \label{results:arraypreload_scalarreplacement_jet}
}
\end{figure}

\begin{figure}[ht] 
  \center
  \includegraphics [scale=1] {results_arraypreload_oak} \\
Алгоритм $ArrayPreload$ \\
1 -- $D$ = 40000, $R$ = 40000; 2 -- $D$ = 40000, $R$ = 4000;\\
3 -- $D$ = 40000, $R$ = 400;   4 -- $D$ = 40000, $R$ = 40;
  \caption{Ускорение тестовой программы (кластер Oak)} 
  \label{results:arraypreload_oak}
\end{figure}

На рис.~\ref{results:arraypreload_oak} показаны графики зависимости значения 
коэффициента ускорения выполнения X10-теста от количества $N$ ВУ после 
применения алгоритма $ArrayPreload$ на кластере Oak c сетью связи InfiniBand 
QDR. В ходе экспериментов варьировалось число $R$ обращений к удаленному 
массиву. В общем случае ускорение зависит от производительности коммуникационной 
сети, количества ВУ, размера массива, количества итераций в цикле (в теле 
которого организован циклический доступ).

\clearpage

\section{Выводы}


%\newpage
%============================================================================================================================

% \section{Параграф - два} \label{sect3_2}

% Некоторый текст.

%\newpage
%============================================================================================================================

% \section{Параграф с подпараграфами} \label{sect3_3}

%\subsection{Подпараграф - один} \label{subsect3_3_1}

%Некоторый текст.

%\subsection{Подпараграф - два} \label{subsect3_3_2}

%Некоторый текст.

\clearpage

