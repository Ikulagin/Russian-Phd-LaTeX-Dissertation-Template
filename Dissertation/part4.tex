\chapter{Оптимизация доступа к удаленным массивам} \label{chapt4}

\section{Итерационный доступ к удаленным массивам в модели PGAS} \label{sect4_1}

Одним из часто встречающихся шаблонов в параллельных PGAS-программах является обращение в цикле к элементам массива (ссылка на рисунок). Ввиду того, что единое глобальное адресное пространство реализуется на распределенной памяти ВУ, массив к которому осуществляется итерационный доступ или его часть могут быть расположены в памяти удаленного (не локального) узла. В этом случае на runtime-систему языка ложится задача по доставке требуемых элементов на узел, оперирующий ими.

\begin{figure}[ht] 
  \center
  \includegraphics [scale=1] {access_to_remote_array}
  \caption{Доступ к элементу массива, расположенного в памяти удаленного ВУ} 
  \label{img:access_to_remote_array}  
\end{figure}

\begin{figure}[ht] 
  \center
  \includegraphics [scale=1] {access_to_remote_array_opt_scalar_replacement}
  \caption{Доступ к элементу массива, расположенного в памяти удаленного ВУ. Оптимизированная версия Scalar Replacement} 
  \label{img:access_to_remote_array_opt_scalar_replacement}  
\end{figure}

\begin{figure}[ht] 
  \center
  \includegraphics [scale=1] {access_to_remote_array_no_opt}
  \caption{Циклический доступ к элементу массива, расположенного в памяти удаленного ВУ} 
  \label{img:access_to_remote_array_no_opt}  
\end{figure}

На данном этапе развития языков семейства PGAS в компиляторах используются относительно простые эвристические алгоритмы. При доступе к одному элементу массива, расположенного в памяти удаленного ВУ, происходит избыточное копирование всего массива в память локального ВУ~\ref{img:access_to_remote_array}. Это создаёт большие накладные расходы, для сокращения которых используется алгоритм (Scalar replacement [ссылка на литературу]), который предполагает использование временных скаляров вместо элементов удаленных массивов в определенных участках кода. Временные скаляры являются копией элементов удаленного массива, к которому осуществляется доступ. Таким образом, при обращении к созданным на удаленном ВУ скалярам будет выполняться копирование только используемых элементов массива, точнее, соответствующих им скаляров ~\ref{img:access_to_remote_array_opt_scalar_replacement}. В случае циклического обращения к элементам удаленного массива, runtime-система языка копирует весь массив на каждой итерации в память локального ВУ ~\ref{img:access_to_remote_array_no_opt}, что является неприемлемым. Использование алгоритма Scalar Replacement в этой ситуации может привести к избыточному копированию: суммарное количество переданных элементов может оказаться больше размера всего массива. 

\section{Алгоритм опережающего копирования удаленных массивов} \label{sect4_2}

Для предотвращения множественного копирования всего удаленного массива в память локального ВУ предложен алгоритм $ArrayPreload$ оптимизации циклического доступа к удаленным массивам, минимизирующий время информационных обменов. $ArrayPreload$ предотвращает многократное копирование массивов, размещенных в памяти других ВУ, выполняя опережающее копирование один раз перед итерациями цикла ~\ref{img:access_to_remote_array_no_opt}.

\begin{figure}[ht] 
  \center
  \includegraphics [scale=1] {access_to_remote_array_opt_arraypreload}
  \caption{Циклический доступ к элементу массива, расположенного в памяти удаленного ВУ. Оптимизированная версия $ArrayPreload$} 
  \label{img:access_to_remote_array_opt_arraypreload}  
\end{figure}

В листинге~\ref{list:at_exmpl_opt} показан пример оптимизации передачи массива $A$ для языка IBM X10. В случае не оптимизированной версии~\ref{list:at_exmpl_no_opt} на каждой итерации цикла массив $A$ передается узлу с номером $id$. В оптимизированной версии ~\ref{list:at_exmpl_opt} производится предварительное копирование массива $A$ на каждый узел один раз, сохранив его в распределённом массиве $localA$. Используемая языке IBM X10 конструкция $at$ семантически соответствует конструкции $on$. 

\begin{ListingEnv}[!h]
    \begin{Verb}
for (i in 0..R) {
    val id: Long = i % Places.MAX_PLACES;
    at (Place.place(id)) {
        // Использование одного элемента A
        // приводит к копированию всего массива
        // на ВУ с номером placeId
        var a: Long = A(i % Size);
    }
}
    \end{Verb}
    \caption{Пример оптимизации передачи массива $A$ в параллельной программе на языке IBM X10. Не оптимизированная версия}
    \label{list:at_exmpl_no_opt}
\end{ListingEnv}

\begin{ListingEnv}[!h]
    \begin{Verb}
// Пролог цикла копирует A на каждый узел
// один раз, сохраняя его в распределённом
// массиве localA
val localA: DistArray[Array[Long]] = ...
for (i in 0..R) {
    val id: Long = i % Places.MAX_PLACES;
    at (Place.place(id)) {
        // Использование локальной копии localA
        // массива A
        var a: Long = localA(id)(i % Size);
    }
}
    \end{Verb}
    \caption{Пример оптимизации передачи массива $A$ в параллельной программе на языке IBM X10. Оптимизированная версия}
    \label{list:at_exmpl_opt}
\end{ListingEnv}

Алгоритм $ArrayPreload$ основан на статическом анализе PGAS-программы, представленной абстрактным синтаксическим деревом (АСД). Каждый узел в АСД имеет определенный тип в зависимости от выполняемой инструкции (например, операторы цикла, ветвления, конструкция передачи управления другому ВУ, объявление переменных и т.д.). На рис. \ref{img:ast_no_opt} приведен фрагмент АСД неоптимизированной программы из листинга \ref{list:at_exmpl_no_opt} на языке IBM X10 [13]. На вход $ArrayPreload$ поступает указатель на корень $Root$ АСД параллельной PGAS-программы. Результатом работы алгоритма является модифицированное АСД программы. 

\begin{figure}[ht] 
  \center
  \includegraphics [scale=0.7] {ast_no_opt}
  \caption{Фрагмент АСД параллельной PGAS программы на языке IBM X10, представленной на листинге \ref{list:at_exmpl_no_opt}} 
  \label{img:ast_no_opt}
\end{figure}

Все основные действия алгоритма производится во время рекурсивного обхода АСД в глубину. На первом этапе выполняется поиск циклов, содержащих обращения к элементам удаленных массивов. Рассмотрим подробнее этот этап. В листинге 4 приведен псевдокод функции Visit, выполняющая рекурсивный обход АСД в глубину. В процессе обхода отыскиваются узлы АСД с типом Loop, которые соответствуют оператору for (листинг 4, строка 6), и запускается функция анализа циклов (листинг 4, строка 7).
Функция ProcessLoop (листинг 5) выполняет проход по всем инструкциям цикла (листинг 5, строка 3) с целью поиска узла АСД типа AtStmt, который соответствует конструкции at (синоним конструкции on) передачи управления другому ВУ (листинг 5, строка 5). Для получения массива поддеревьев, соответствующих дочерним инструкциям, используется функция GetStatements. В случае обнаружения конструкции at вызывается функция ProcessAtStmt (листинг 5, строка 6), реализующая поиск операции чтения элементов массива типа Array (листинг 6). Для упрощения псевдокода в листинг 6 рассматривается случай использования удаленных массивов только при объявлении переменных в выражениях инициализации (LocalDeclaration). В общем случае последовательность действий анализа кода, выполняющегося на удаленном ВУ, будет зависеть от конкретной программной реализации модели PGAS. В процессе анализа инструкции at перебираются все её инструкции до тех пор, пока не будет найден узел АСД с типом LocalDeclaration (листинг 6, строка 5), указывающий на локальное объявление переменных. Затем необходимо проверить наличие операций чтения элементов массива в выражении инициализации. В описании алгоритма предполагается, что обращение к элементу массива выполняется при помощи вызова перегруженного оператора круглых скобок.  При помощи функции GetInitialization получается узел АСД, соответствующий выражению инициализации объявляемой переменной (листинг 6, строка 7). Если полученный узел имеет тип Call (указывает на вызов метода объекта, листинг 6, строка 10), а объект -- тип Array (листинг 6, строка 10), то выражение содержит обращение к массиву. На этом завершается первый этап работы алгоритма.
 На втором этапе выполняется проверка найденного массива. Для применения оптимизации необходимо убедиться в том, что массив не изменяется на протяжении всех итераций цикла, иначе применение оптимизации нарушит оригинальную семантику программы. Способ проверки неизменяемости массива зависит от реализации компилятора языка, например, данная проверка может быть реализована на основе заранее построенного контекста каждой инструкции цикла, или на основе контекста цикла целиком. Поэтому алгоритм проверки подробно не рассматривается, а используется функция IsReadOnlyArray, выполняющая её. Функция IsReadOnlyArray возвращает истину, если массив не изменяется на протяжении всего цикла, ложь – в противном случае. Функция GetCallVarName возвращает имя объекта, чей метод вызывается.
 
На третьем этапе выполняется трансформация АСД параллельной программы. В случае успешной проверки найденного массива (листинг 6, строки 10-11) необходимо создать пролог цикла, копирующий удаленный массив в память ВУ один раз перед итерациями, а также произвести замену чтения удаленного массива на скопированную прологом цикла локальную копию. Опережающее копирование можно выполнить различными способами, в зависимости от реализации модели PGAS. В данной работе опережающее копирование реализуется с использованием распределенного массива. Достоинством данной реализации является то, что она не требует дополнительного расширения модели PGAS. Программист вручную может выполнять данные преобразования после тщательного анализа кода программы, но это трудоёмко.
Предлагаемая реализация заключается в создании распределенного массива длиной по количеству ВУ, элементы которого распределены по одному на каждый ВУ. Каждый элемент будет представлять копию удаленного массива. Таким образом, каждый ВУ будет хранить локальную копию используемого массива.
Для создания пролога цикла необходимо:
(1)	Определить позицию оптимизируемого цикла в исходном коде (листинг 6, строка 12). Это необходимо для того, чтобы знать, куда необходимо вставить пролог цикла.
(2)	Генерация имени локальной копии массива (листинг 6, строка 15).
(3)	Формирование фрагмента АСД, который соответствует созданию распределенного массива для организации опережающего копирования согласно выше описанному способу (листинг 6, строка 17).
(4)	Вставка сформированного фрагмента в заданную позицию АСД программы, а именно, перед рассматриваемым циклом (листинг 6, строка 25). Позиция цикла определялась в строке 12.
После добавления пролога цикла необходимо выполнить замену чтения элементов удаленного массива на чтение элементов локальной копии. Для этого необходимо: 
(1)	Получить имя локальной копии массива (листинг 6, строка 15).
(2)	Получить список аргументов (листинг 6, строка 13). Так как обращение к элементу массива – это вызов перегруженного оператора круглых скобок, то аргументом является индекс элемента массива. Обращение к локальной копии массива будет производиться по тем же самым индексам, что и обращение к удаленному массиву.
(3)	Создать фрагмент АСД, выполняющий чтение используемых элементов локального массива (листинг 6, строка 21).
(4)	Выполнить замену фрагментов АСД (листинг 6, строка 23).

Рассмотрим описанные действия на фрагменте АСД из рис. 8. В процессе рекурсивного обхода будет обнаружен узел цикла for (i in 0..R), имеющий тип Loop. Поддерево с корнем, соответствующее циклу for, передаёься в функцию ProcessLoop для поиска в теле цикла инструкции at передачи управления другому ВУ. После обнаружения инструкции at она передается в функцию ProcessAtStmt для поиска в ней чтения элементов массива, расположенных в памяти удаленного ВУ. Таким массивом является А. Массив А не изменяется на протяжении всего цикла, значит можно произвести оптимизацию данного участка программы. Для опережающего копирования создаётся распределенный массив localA, элементами которого является массив A. После чего в конструкции at будет использоваться массив localA вместо удаленного массива A. 
На рис. 9 приведен фрагмент АСД программы на языке IBM X10 после применения оптимизирующей трансформации. Жирным выделены узлы, подвергшиеся модификации. Был добавлен пролог цикла val localA: DistArray[Array[Long]], а также заменено обращение к массиву A на обращение к массиву localA. 



%\newpage
%============================================================================================================================

% \section{Параграф - два} \label{sect3_2}

% Некоторый текст.

%\newpage
%============================================================================================================================

% \section{Параграф с подпараграфами} \label{sect3_3}

%\subsection{Подпараграф - один} \label{subsect3_3_1}

%Некоторый текст.

%\subsection{Подпараграф - два} \label{subsect3_3_2}

%Некоторый текст.

\clearpage
