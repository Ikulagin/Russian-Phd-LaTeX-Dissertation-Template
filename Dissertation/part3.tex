\chapter{Вёрстка таблиц} \label{chapt3}

\section{Таблица обыкновенная} \label{sect3_1}

Так размещается таблица:

\begin{table} [htbp]
  \centering
  \changecaptionwidth\captionwidth{15cm}
  \caption{Название таблицы}\label{Ts0Sib}%
  \begin{tabular}{| p{3cm} || p{3cm} | p{3cm} | p{4cm}l |}
  \hline
  \hline
  Месяц   & \centering $T_{min}$, К & \centering $T_{max}$, К &\centering  $(T_{max} - T_{min})$, К & \\
  \hline
  Декабрь &\centering  253.575   &\centering  257.778    &\centering      4.203  &   \\
  Январь  &\centering  262.431   &\centering  263.214    &\centering      0.783  &   \\
  Февраль &\centering  261.184   &\centering  260.381    &\centering     $-$0.803  &   \\
  \hline
  \hline
  \end{tabular}
\end{table}

\begin{table} [htbp]% Пример записи таблицы с номером, но без отображаемого наименования
	\centering
	\parbox{9cm}{% чтобы лучше смотрелось, подбирается самостоятельно
        \captiondelim{}% должен стоять до самого пустого caption
        \caption{}%
        \label{tbl:test1}%
        \begin{SingleSpace}
    	\begin{tabular}{ | c | c | c | c |}
    	\hline
    	Оконная функция	& ${2N}$ & ${4N}$	& ${8N}$	\\ \hline
    	Прямоугольное 	& 8.72 	 & 8.77		& 8.77		\\ \hline
    	Ханна		& 7.96 	 & 7.93		& 7.93		\\ \hline
    	Хэмминга	& 8.72 	 & 8.77		& 8.77		\\ \hline
    	Блэкмана	& 8.72 	 & 8.77		& 8.77		\\ \hline
    	\end{tabular}%
    	\end{SingleSpace}
	}
\end{table}

Таблица \ref{tbl:test2} "--- пример таблицы, оформленной в~классическом книжном варианте или~очень близко к~нему. \mbox{ГОСТу} по~сути не~противоречит. Можно ещё~улучшить представление, с~помощью пакета \verb|siunitx| или~подобного.

\begin{table} [htbp]%
    \centering
	\caption{Наименование таблицы, очень длинное наименование таблицы, чтобы посмотреть как оно будет располагаться на~нескольких строках и~переноситься}%
	\label{tbl:test2}% label всегда желательно идти после caption
    \renewcommand{\arraystretch}{1.5}%% Увеличение расстояния между рядами, для улучшения восприятия.
    \begin{SingleSpace}
	\begin{tabular}{@{}@{\extracolsep{20pt}}llll@{}} %Вертикальные полосы не используются принципиально, как и лишние горизонтальные (допускается по ГОСТ 2.105 пункт 4.4.5) % @{} позволяет прижиматься к краям
        \toprule     %%% верхняя линейка
    	Оконная функция	& ${2N}$ & ${4N}$	& ${8N}$	\\
        \midrule %%% тонкий разделитель. Отделяет названия столбцов. Обязателен по ГОСТ 2.105 пункт 4.4.5 
    	Прямоугольное 	& 8.72 	 & 8.77		& 8.77		\\
    	Ханна		& 7.96 	 & 7.93		& 7.93		\\
    	Хэмминга	& 8.72 	 & 8.77		& 8.77		\\
    	Блэкмана	& 8.72 	 & 8.77		& 8.77		\\
        \bottomrule %%% нижняя линейка
	\end{tabular}%
   	\end{SingleSpace}
\end{table}

\section{Таблица с многострочными ячейками и примечанием}

Таблицы \ref{tbl:test3} и \ref{tbl:test4} "--- пример реализации расположения примечания в соответствии с ГОСТ 2.105. Каждый вариант со своими достоинствами и недостатками. Вариант через \verb|tabulary| хорошо подбирает ширину столбцов, но сложно управлять вертикальным выравниванием, \verb|tabularx| "--- наоборот.
\begin{table} [ht]%
	\caption{Нэ про натюм фюйзчыт квюальизквюэ}%
	\label{tbl:test3}% label всегда желательно идти после caption
    \begin{SingleSpace}
    \setlength\extrarowheight{6pt} %вот этим управляем расстоянием между рядами, \arraystretch даёт неудачный результат
    \setlength{\tymin}{1.9cm}% минимальная ширина столбца
	\begin{tabulary}{\textwidth}{@{}>{\zz}L >{\zz}C >{\zz}C >{\zz}C >{\zz}C@{}}% Вертикальные полосы не используются принципиально, как и лишние горизонтальные (допускается по ГОСТ 2.105 пункт 4.4.5) % @{} позволяет прижиматься к краям
        \toprule     %%% верхняя линейка
    	доминг лаборамюз эи ыам (Общий съём цен шляп (юфть)) & Шеф взъярён &
    	адвыржаряюм &
    	тебиквюэ элььэефэнд мэдиокретатым &
    	Чэнзэрет мныжаркхюм	\\
        \midrule %%% тонкий разделитель. Отделяет названия столбцов. Обязателен по ГОСТ 2.105 пункт 4.4.5 
         Эй, жлоб! Где туз? Прячь юных съёмщиц в~шкаф Плюш изъят. Бьём чуждый цен хвощ! &
        ${\approx}$ &
        ${\approx}$ &
        ${\approx}$ &
        $ + $ \\
        Эх, чужак! Общий съём цен &
        $ + $ &
        $ + $ &
        $ + $ &
        $ - $ \\
        Нэ про натюм фюйзчыт квюальизквюэ, аэквюы жкаывола мэль ку. Ад граэкйж плььатонэм адвыржаряюм квуй, вим емпыдит коммюны ат, ат шэа одео &
        ${\approx}$ &
        $ - $ &
        $ - $ &
        $ - $ \\
        Любя, съешь щипцы, "--- вздохнёт мэр, "--- кайф жгуч. &
        $ - $ &
        $ + $ &
        $ + $ &
        ${\approx}$ \\
        Нэ про натюм фюйзчыт квюальизквюэ, аэквюы жкаывола мэль ку. Ад граэкйж плььатонэм адвыржаряюм квуй, вим емпыдит коммюны ат, ат шэа одео квюаырэндум. Вёртюты ажжынтиор эффикеэнди эож нэ. &
        $ + $ &
        $ - $ &
        ${\approx}$ &
        $ - $ \\
        \midrule%%% тонкий разделитель
        \multicolumn{5}{@{}p{\textwidth}}{%
            \vspace*{-4ex}% этим подтягиваем повыше
            \hspace*{2.5em}% абзацный отступ - требование ГОСТ 2.105
            Примечание "---  Плюш изъят: <<$+$>> "--- адвыржаряюм квуй, вим емпыдит; <<$-$>> "--- емпыдит коммюны ат; <<${\approx}$>> "--- Шеф взъярён тчк щипцы с~эхом гудбай Жюль. Эй, жлоб! Где туз? Прячь юных съёмщиц в~шкаф. Экс-граф?
        }
        \\
        \bottomrule %%% нижняя линейка
	\end{tabulary}%
    \end{SingleSpace}
\end{table}

Из-за того, что таблица \ref{tbl:test3} не помещается на той же странице (при компилировании pdflatex), всё её содержимое переносится на следующую, ближайшую, а~этот текст идёт перед ней.
\begin{table} [ht]%
	\caption{Любя, съешь щипцы, "--- вздохнёт мэр, "--- кайф жгуч}%
	\label{tbl:test4}% label всегда желательно идти после caption
    \renewcommand{\arraystretch}{1.6}%% Увеличение расстояния между рядами, для улучшения восприятия.
	\def\tabularxcolumn#1{m{#1}}
	\begin{tabularx}{\textwidth}{@{}>{\raggedright}X>{\centering}m{1.9cm} >{\centering}m{1.9cm} >{\centering}m{1.9cm} >{\centering\arraybackslash}m{1.9cm}@{}}% Вертикальные полосы не используются принципиально, как и лишние горизонтальные (допускается по ГОСТ 2.105 пункт 4.4.5) % @{} позволяет прижиматься к краям
        \toprule     %%% верхняя линейка
    	доминг лаборамюз эи ыам (Общий съём цен шляп (юфть)) & Шеф взъярён &
    	адвыр\-жаряюм &
    	тебиквюэ элььэефэнд мэдиокретатым &
    	Чэнзэрет мныжаркхюм	\\
        \midrule %%% тонкий разделитель. Отделяет названия столбцов. Обязателен по ГОСТ 2.105 пункт 4.4.5 
         Эй, жлоб! Где туз? Прячь юных съёмщиц в~шкаф Плюш изъят. Бьём чуждый цен хвощ! &
        ${\approx}$ &
        ${\approx}$ &
        ${\approx}$ &
        $ + $ \\
        Эх, чужак! Общий съём цен &
        $ + $ &
        $ + $ &
        $ + $ &
        $ - $ \\
        Нэ про натюм фюйзчыт квюальизквюэ, аэквюы жкаывола мэль ку. Ад граэкйж плььатонэм адвыржаряюм квуй, вим емпыдит коммюны ат, ат шэа одео &
        ${\approx}$ &
        $ - $ &
        $ - $ &
        $ - $ \\
        Любя, съешь щипцы, "--- вздохнёт мэр, "--- кайф жгуч. &
        $ - $ &
        $ + $ &
        $ + $ &
        ${\approx}$ \\
        Нэ про натюм фюйзчыт квюальизквюэ, аэквюы жкаывола мэль ку. Ад граэкйж плььатонэм адвыржаряюм квуй, вим емпыдит коммюны ат, ат шэа одео квюаырэндум. Вёртюты ажжынтиор эффикеэнди эож нэ. &
        $ + $ &
        $ - $ &
        ${\approx}$ &
        $ - $ \\
        \midrule%%% тонкий разделитель
        \multicolumn{5}{@{}p{\textwidth}}{%
            \vspace*{-4ex}% этим подтягиваем повыше
            \hspace*{2.5em}% абзацный отступ - требование ГОСТ 2.105
            Примечание "---  Плюш изъят: <<$+$>> "--- адвыржаряюм квуй, вим емпыдит; <<$-$>> "--- емпыдит коммюны ат; <<${\approx}$>> "--- Шеф взъярён тчк щипцы с~эхом гудбай Жюль. Эй, жлоб! Где туз? Прячь юных съёмщиц в~шкаф. Экс-граф?
        }
        \\
        \bottomrule %%% нижняя линейка
	\end{tabularx}%
\end{table}

\chapter{Оптимизация выполнения программ на многоядерных SMP/NUMA системах} 
\label{SMP|NUMA_STM}
\section{Программная транзакционная память}
Международным комитетом ISO по стандартизации языка C++, в рамках рабочей группы 
WG21, ведутся работы по внедрению транзакционной памяти в стандарт языка. 
Окончательное внедрение планируется в стандарт С++17. На сегодняшний день 
предложен черновой вариант спецификации поддержки транзакционной памяти в С++ 
\cite{luchango_maurer_moir}. Она реализована в компиляторе GCC, начиная с версии 
4.8 и предоставляет ключевые слова \_\_transaction\_atomic, 
\_\_transaction\_relaxed для создания транзакционных секций, а также 
\_\_transaction\_cancel для принудительной отмены транзакции. 

Для выполнения транзакционных секций runtime-системой создаются транзакции. 
\textit{Транзакция} (transaction) --- это конечная последовательность операций 
транзакционного чтения/записи памяти. Операция \textit{транзакционного чтения} 
выполняет копирование содержимого указанного участка общей памяти в 
соответствующий участок локальной памяти потока. \textit{Транзакционная запись} 
копирует содержимое указанного участка локальной памяти в соответствующий 
участок общей памяти, доступной всем потокам.

Инструкции транзакций выполняются потоками параллельно (конкурентно). После 
завершения выполнения транзакция может быть либо \textit{зафиксирована} 
(commit), либо \textit{отменена} (cancel). Фиксация транзакции подразумевает, 
что все сделанные в рамках нее изменения памяти становятся необратимыми. При 
отмене транзакции ее выполнение прерывается, а состояние всех модифицированных 
областей памяти восстанавливается в исходное с последующим перезапуском 
транзакции (\textit{откат транзакции}, rollback).

Отмена транзакции происходит в случае \textit{обнаружения конфликта} --- 
ситуации, при которой два или более потока обращаются к одному и тому же участку 
памяти и как минимум один из них выполняет операцию записи.

Для разрешения конфликта разработаны различные походы, например, можно 
приостановить на некоторое время или отменить одну из конфликтующих транзакций.

На рис. \ref{transactional_section_exm.txt} представлен пример создания 
транзакционной секции, в теле которой выполняется добавление элемента в 
хэш-таблицу множеством потоков. После выполнения тела транзакционной секции 
каждый поток приступит к выполнению кода, следующего за ней, в случае отсутствия 
конфликтов. В противном случае поток повторно будет выполнять транзакцию до тех 
пор, пока его транзакция не будет успешно зафиксирована.

\code[10.5cm]{frame=single}{transactional_section_exm.txt}{Добавление пары 
$(key, value)$ в хеш-таблицу $h$}

Основными аспектами реализации транзакционной памяти в runtime-системах 
являются:
\begin{itemize}
\item политика обновления объектов в памяти;
\item стратегия обнаружения конфликтов;
\item метод разрешения конфликтов.
\end{itemize}

Политика обновления объектов в памяти определяет, когда изменения объектов в 
рамках транзакции будут записаны в память. Распространение получили две основные
политики --- ленивая и ранняя. \textit{Ленивая} политика обновления объектов в 
памяти (lazy version management) откладывает все операции с объектами до момента
фиксации транзакции. Все операции записываются в специальном журнале (redo log),
который при фиксации используется для отложенного выполнения операций. Очевидно,
что это замедляет операцию фиксации, но существенно упрощает процедуры ее отмены
и восстановления. Примером реализаций ТП, использующих данную политику, являются
RSTM-LLT \cite{rstm_proj} и RSTM-RingSW \cite{spear_strategy_for_cm, 
spear_ringstm}.

\textit{Ранняя политика обновления} (eager version management) предполагает, что
все изменения объектов сразу записываются в память. В журнале отката (undo log) 
фиксируются все выполненные операции с памятью. Он используется для 
восстановления оригинального состояния модифицируемых участков памяти в случае 
возникновения конфликта. Эта политика характеризуется быстрым выполнением 
операции фиксации транзакции, но медленным выполнением процедуры ее отмены. 
Примерами реализаций, использующих раннюю политику обновления данных, являются 
GCC (libitm), TinySTM \cite{felber_fetzer_marlier_riegel}, LSA-STM 
\cite{riegel_felber_fetzer}, Log-TM \cite{kevin_bobba_logtm}, RSTM 
\cite{rstm_proj} и др.
 
Момент времени, когда инициируется алгоритм обнаружения конфликта, определяется 
\textit{стратегией обнаружения конфликтов}. При \textit{отложенной стратегии} 
(lazy conflict detection) алгоритм обнаружения конфликтов запускается на этапе 
фиксации транзакции \cite{spear_ringstm}. Недостатком этой стратегии является 
то, что временной интервал между возникновением конфликта и его обнаружением 
может быть достаточно большим. Эта стратегия используется в RSTM-LLT 
\cite{rstm_proj} и RSTM-RingSW \cite{rstm_proj, spear_strategy_for_cm, 
spear_ringstm}. 

\textit{Пессимистичная стратегия обнаружения конфликтов}(eager conflict 
detection) запускает алгоритм их обнаружения при каждой операции обращения к 
памяти. Такой подход позволяет избежать недостатков отложенной стратегии, но 
может привести к значительным накладным расходам, а также, в некоторых случаях, 
может привести к увеличению числа откатов транзакций. Стратегия реализована в 
TinySTM \cite{felber_fetzer_marlier_riegel}, LSA-STM \cite{riegel_felber_fetzer} 
и TL2 \cite{dice_shavit_tl2}. В компиляторе GCC (libitm) реализован 
комбинированный подход к обнаружению конфликтов --- отложенная стратегия 
используется совместно с пессимистической.

\section{Задача оптимального выбора значений параметров реализации STM}
\section{Алгоритм динамического регулирования значений параметров
  реализации STM}
\section{Алгоритм выбора значений параметров реализации STM по результатам
  предварительного профилирования}

Для обнаружения конфликтных операций требуется отслеживать изменения состояния 
используемых областей памяти. Информация о состоянии может соответствовать 
областям памяти различной степени гранулярности. Выбор гранулярности обнаружения 
конфликтов --- один из ключевых моментов при реализации программной 
транзакционной памяти.

На сегодняшний день используются два уровня гранулярности: \textit{уровень 
программных объектов} (object-based STM) и \textit{уровень слов памяти} 
(word-based STM). Уровень программных объектов подразумевает отображение 
объектов модели памяти языка (объекты C++, Java, Scala) на метаданные 
runtime-библиотеки. При использовании уровня слов памяти осуществляется 
отображение блоков линейного адресного пространства процесса на метаданные. 
Метаданные хранятся в таблице, каждая строка которой соответствует объекту 
программы или области линейного адресного пространства процесса. В строке 
содержатся номер транзакции, выполняющей операцию чтения/записи памяти; номер 
версии  отображаемых данных; их состояние и др. Модификация метаданных 
выполняется runtime-системой с помощью атомарных операций процессора.

В данной работе рассматривается реализация программной транзакционной памяти в 
компиляторе GCC, использующая уровень слов памяти (в версиях GCC 4.8+ размер 
блока – 16 байт).

На рис. \ref{metadata_exm} представлен пример организации метаданных 
транзакционной памяти с использованием уровня слов памяти (GCC 4.8+). Линейное 
адресное пространство процесса фиксированными блоками циклически отображается на 
строки таблицы, подобно кешу прямого отображения. Выполнение операции записи 
приведет к изменению поля <<состояние>> соответствующей строки таблицы на 
<<заблокировано>>. Доступ к области линейного адресного пространства, у которой 
соответствующая строка таблицы помечена как <<заблокировано>>, приводит к 
конфликту. 

\fig{scale=0.8}{metadata_exm}{Таблица с метаданными GCC 4.8+ (word-based STM): 
$B = 16$, $S = 2^{19}$}

Основными параметрами транзакционной памяти с использованием уровня слов памяти 
являются число $S$ строк таблицы и количество $B$ адресов линейного адресного 
пространства, отображаемых на одну строку таблицы. От выбора этих параметров 
зависит число ложных конфликтов --- ситуаций аналогичных ситуации ложного 
разделения данных при работе кеша процессора. В текущей реализации GCC (4.8-5.1) 
эти параметры фиксированы 
\cite{felber_fetzen_riegel_dynamic_performance_tuning}. 

При отображении блоков линейного адресного пространства процесса на метаданные 
runtime-библиотеки возникают коллизии. Это неизбежно, так как размер таблицы 
метаданных гораздо меньше размера линейного адресного пространства процесса. 
Коллизии приводят к возникновению ложных конфликтов. \textit{Ложный конфликт} 
--- ситуация, при которой два или более потока во время выполнения транзакции 
обращаются к разным участкам линейного адресного пространства, но сопровождаемым 
одними и теми же метаданными о состоянии, и как минимум один поток выполняет 
операцию записи. Таким образом, ложный конфликт --- это конфликт, который 
происходит не на уровне данных программы, а на уровне метаданных 
runtime-библиотеки.

Возникновение ложных конфликтов приводит к откату транзакций так же, как и 
возникновение обычных конфликтов, несмотря на то что состояние гонки за данными 
не возникает, что влечет за собой увеличение времени выполнения STM-программ. 
Сократив число ложных конфликтов, можно существенно уменьшить время выполнения 
программы.

На рис. \ref{false_conf_exm} показан пример возникновения ложного конфликта в 
результате коллизии отображения линейного адресного пространства на строку 
таблицы. Поток 1 при выполнении операции записи над областью памяти с адресом 
$A1$ захватывает соответствующую строку таблицы. Выполнение операции чтения над 
областью памяти с адресом $A2$ потоком 2 приводит к возникновению конфликта, 
несмотря на то что операции чтения и записи выполняются над различными адресами. 
Последнее обусловлено тем, что 1 и 2 отображены на одну строку таблицы 
метаданных.

\fig{scale=0.8}{false_conf_exm}{Пример возникновения ложного конфликта при 
выполнении двух транзакций (GCC 4.8+)}

В работе \cite{zilles_rajwar_false_conf} для минимизации числа ложных конфликтов 
предлагается использовать вместо таблицы с прямой адресацией (как в GCC 4.8+), в 
которой индексом является часть линейного адреса, хеш-таблицу, коллизии в 
которой разрешаются методом цепочек. В случае отображения нескольких адресов на 
одну запись таблицы каждый адрес добавляется в список и помечается тэгом для 
идентификации (рис. 5). Такой подход позволяет избежать ложных конфликтов, 
однако накладные расходы на синхронизацию доступа к метаданным существенно 
возрастают, так как значительно увеличивается количество атомарных операций 
<<сравнение с обменом>> (compare and swap --- CAS).

\fig{scale=0.7}{metadata_chaining}{Хеш-таблица для хранения метаданных}

Авторами предложен метод, позволяющий сократить число ложных конфликтов в 
STM-программах. Предполагается, что метаданные организованы в виде таблицы с 
прямой адресацией. Суть метода заключается в автоматической настройке параметров 
$S$ и $B$ таблицы под динамические характеристики конкретной STM-программы. 
Метод включает три этапа.

\textbf{Этап 1}. Внедрение функций библиотеки профилирования в транзакционные 
секции. На первом этапе выполняется компиляция C/C++ STM-программы с 
использованием разработанного модуля анализа транзакционных секций и внедрения 
вызова функций библиотеки профилирования (модуль расширения GCC). В ходе 
статического анализа транзакционных секций STM-программ выполняется внедрение 
кода для регистрации обращений к функциям Intel TM ABI (\_ITM\_beginTransaction, 
\_ITM\_comitTransaction, \_ITM\_LU4, \_ITM\_WU4 и др.). Детали реализации модуля 
описаны ниже.

\textbf{Этап 2}. Профилирование программы. На данном этапе выполняется запуск 
STM-программы в режиме профилирования. Профилировщик регистрирует все операции 
чтения/записи памяти в транзакциях. В результате формируется протокол (trace), 
содержащий информацию о ходе выполнения транзакционных секций:
\begin{itemize}
\item адрес и размер области памяти, над которой выполняется операция;
\item временная метка (timestamp) начала выполнения операции.
\end{itemize}

\textbf{Этап 3}. Настройка параметров таблицы. По протоколу определяются средний 
размер $W$ читаемой/записываемой области памяти во время выполнения транзакций. 
По значению $W$ подбираются субоптимальные параметры $B$ и $S$ таблицы, с 
которыми STM-программа компилируется. Эксперименты с тестовыми STM-программами 
из пакета STAMP (6 типов STM-программ) позволили сформулировать эвристические 
правила для подбора параметров $B$ и $S$ по значению $W$. Значение параметра $S$ 
целесообразно выбирать из множества $\{2^{18}, 2^{19}, 2^{20}, 2^{21}\}$. 
Значение параметра $B$ выбирается следующим образом:
\begin{itemize}
\item если $\textit{W} = 1$ байт, то $\textit{B} = 2^{4}$ байт;
\item если $\textit{W} = 4$ байт, то $\textit{B} = 2^{6}$ байт;
\item если $\textit{W} = 8$ байт, то $\textit{B} = 2^{7}$ байт;
\item если $\textit{W} >= 64$ байт, то $\textit{B} = 2^{8}$ байт.
\end{itemize}

\section{Программный инструментарий для сокращения ложных конфликтов}
Авторами разработан программный инструментарий (STM false conflict optimizer) 
для оптимизации ложных конфликтов, возникающих при выполнении параллельных 
программ с транзакционной памятью. Инструментарий позволяет выполнять 
профилирование STM-программ. Информация, полученная в результате профилирования, 
предоставляет достаточно сведений о динамических характеристиках транзакционных 
секций для того, чтобы ответить на вопрос: <<Фиксации каких транзакций или 
операции над какими данными приводят к отмене других транзакций?>>. Кроме этого, 
разработанное программное средство позволяет определить значения субоптимальных 
значений параметров реализации runtime-системы ТП, а именно число строк таблицы 
метаданных о состоянии областей памяти и количество адресов линейного адресного 
пространства, отображаемых на одну строку таблицы.

\subsection{Функциональная структура пакета}
Программный инструментарий состоит из трех основных компонентов (рис. 
\ref{stm_fc_optimizer}):
\begin{itemize}
\item модуль внедрения функций библиотеки профилирования в код транзакционных 
секций ($tm\_prof\_analyzer$);
\item библиотека профилирования параллельной программы с транзакционной памятью 
($libitm\_prof$);
\item модуль анализа протокола выполнения транзакционных секций, установки 
значений параметров реализации ($tm\_proto\_analyzer$).
\end{itemize}

\fig{scale=0.8}{stm_fc_optimizer}{Функциональная структура разработанного 
пакета; $1$ --- компиляция STM-программы; $2$ --- запуск STM-программы под 
управление профилировщика; $3$ --- обращение к функциям профилировщика}

\subsection{Внедрение функций профилировщика}
STM-компилятор осуществляет трансляцию транзакционных секций в 
последовательность вызовов функций runtime-системы поддержки 
TM~\cite{olszewski_cutler_judostm}. Компания Intel предложила спецификацию ABI 
для runtime-систем поддержки транзакционной памяти --- 
Intel~TM~ABI~\cite{intel_tm_abi}. Компилятор GCC, библиотека libitm, реализует 
этот интерфейс начиная с версии 4.8. На рис. \ref{gcc_transform_exm.txt} 
представлен пример трансляции компилятором GCC транзакционной секции в обращения 
к функциям Intel TM ABI.

\code[16cm]{frame=single}{gcc_transform_exm.txt}{Трансляция транзакционной 
секции компилятором GCC; код слева --- исходная транзакционная секция; код 
справа --- промежуточное представление трансформированной транзакционной секции}

В общем случае последовательность выполнения транзакции следующая: 
\begin{enumerate}
\item Создание транзакции (вызов \_ITM\_beginTransaction) и анализ ее состояния. 
Если состояние транзакции содержит флаг принудительной отмены, то выполнение 
продолжается с метки <L3>, т.е. осуществляется выход из транзакции, иначе 
выполнение тела транзакции начинается с метки <L2>.
\item  Выполнение транзакции. Если выполняется принудительная отмена транзакции, 
то в состоянии устанавливается флаг принудительной отмены (a\_abortTransaction) 
и управление передается метке <L1>.
\item Попытка фиксации транзакции (вызов \_ITM\_commitTransaction). В случае 
возникновения конфликта транзакция отменяется, в состояние транзакции 
записывается причина отмены и выполнение транзакции повторяется начиная с метки 
<L1>.
\end{enumerate}

Разработанный модуль $tm\_prof\_analyzer$ внедрения функций библиотеки 
профилирования выполнен в виде встраиваемого модуля компилятора GCC. Программист 
компилирует STM-программу с ключом $-fplugin=tm\_prof\_analyzer.so$. Модуль 
внедрения выполняет анализ промежуточного представления $GIMPLE$ транзакционных 
секций и добавляет функции регистрации обращений к функциям Intel TM ABI: 
регистрация начала транзакции и ее фиксации, транзакционное чтения/запись 
областей памяти.

На рис. \ref{tm_prof_analyzer_exm.txt} представлен пример внедрения вызовов 
функций библиотеки профилирования в транзакционную секцию. Функции с префиксом 
$tm\_prof\_$ выполняют регистрацию событий.

\code[16cm]{frame=single}{tm_prof_analyzer_exm.txt}{Встраивание в транзакционную 
секцию функций библиотеки профилирования; код слева --- исходная транзакционная 
секция; код справа --- промежуточное представление трансформированной 
транзакционной секции}

Во время выполнения STM-программы под управлением профилировщика 
($libitm\_prof$), функции регистрации обращений к интерфейсам Intel TM ABI 
заносят в протокол адреса и размер областей памяти, над которыми выполняются 
операции, а также время начала выполнения операций. После завершения выполнения 
STM-программы формируется протокол выполнения программы, на основе которого 
модуль анализа ($tm\_proto\_analyzer$) осуществляет выбор субоптимальных 
параметров таблицы метаданных транзакционной памяти.

\section{Инструментарий профилирования}
\section{Экспериментальное исследование}

Экспериментальное исследование проводилось на вычислительной системе, оснащенной 
двумя четырехъядерными процессорами Intel Xeon E5420. В данных процессорах 
отсутствует поддержка аппаратной транзакционной памяти (Intel TSX). В качестве 
тестовых программ использовались многопоточные STM-программы из пакета STAMP 
\cite{spear_strategy_for_cm, spear_ringstm, dice_shavit_tl2}. Число потоков 
варьировалось от 1 до 8. Тесты собирались компилятором GCC 5.1.1. Операционная 
система GNU/Linux Fedora 21 x86\_64. 

В рамках экспериментов измерялись значения двух показателей:
\begin{itemize}
\item время $t$ выполнения STM-программы;
\item количество $C$ ложных конфликтов в программе.
\end{itemize}

На рис.~\ref{fc_S_const}, ~\ref{fc_B_const}, ~\ref{time_B_const}, 
~\ref{time_B_const} показана зависимость количества $C$ ложных конфликтов и 
времени $t$ выполнения теста от числа потоков при различных значениях параметров 
$B$ и $S$. Результаты приведены для программы genome из пакета STAMP. В ней 
порядка 10 транзакционных секций, реализующих операции над хеш-таблицей и 
связными списками. Видно, что увеличение значений параметров $S$ и $B$ приводит 
к уменьшению числа возможных коллизий (ложных конфликтов), возникающих при 
отображении адресов линейного адресного пространства процесса на записи таблицы. 
При размере таблицы $2^{21}$ записей, на каждую из которых отображается $2^{6}$ 
адресов линейного адресного пространства, достигается минимум времени выполнения 
теста genome, а также минимум числа ложных конфликтов. 

\begin{figure}
\centering
\begin{subfigure}{0.5\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{fc_S_const}
  \caption{$S = 2^{19}$}
  \label{fc_S_const}
\end{subfigure}%
\begin{subfigure}{0.5\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{fc_B_const}
  \caption{$B = 2^6$}
  \label{fc_B_const}
\end{subfigure}
\caption{Зависимость числа $C$ ложных конфликтов от числа $N$ потоков}
\label{fc_N}
\end{figure}

\begin{figure}
\centering
\begin{subfigure}{0.5\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{time_S_const}
  \caption{$S = 2^{19}$}
  \label{time_S_const}
\end{subfigure}%
\begin{subfigure}{0.5\textwidth}
  \centering
  \includegraphics[width=0.8\linewidth]{time_B_const}
  \caption{$B = 2^6$}
  \label{time_B_const}
\end{subfigure}
\caption{Зависимость времени $t$ выполнения теста от числа $N$ потоков}
\label{time_N}
\end{figure}

Время выполнения теста genome удалось сократить в среднем на 20\% за счет 
минимизации числа ложных конфликтов.

\section{Выводы}

%\newpage
%============================================================================================================================

% \section{Параграф - два} \label{sect3_2}

% Некоторый текст.

%\newpage
%============================================================================================================================

% \section{Параграф с подпараграфами} \label{sect3_3}

%\subsection{Подпараграф - один} \label{subsect3_3_1}

%Некоторый текст.

%\subsection{Подпараграф - два} \label{subsect3_3_2}

%Некоторый текст.

\clearpage


